// src/app/api/chat/route.js

import { NextResponse } from 'next/server';
import OpenAI from 'openai';
import mongoose from 'mongoose';
import CompanyInfo from '@/src/models/CompanyInfo';
import dotenv from 'dotenv';
import yahooFinance from 'yahoo-finance2';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';

dotenv.config({ path: '.env.local' });

const MONGODB_URI = process.env.MONGODB_URI;

// Reuse MongoDB connection in a serverless environment
if (!mongoose.connection.readyState) {
  mongoose
    .connect(MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    })
    .then(() => console.log('Connected to MongoDB Atlas'))
    .catch((err) => console.error('MongoDB connection error:', err));
}

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

const functions = [
  {
    name: 'get_stock_price',
    description:
      'Get real-time stock price (current quote), historical price data, and basic information for one or more stock symbols. This function always returns data for Indian stocks only.',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description:
            'Array of stock symbols like ["RELIANCE", "TCS"] for Reliance and TCS.',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter stocks with current price under this value (in INR).',
        },
      },
      required: ['symbols'],
    },
  },
  {
    name: 'get_crypto_price',
    description:
      'Get real-time cryptocurrency price (current quote), historical price data, and basic information for one or more crypto symbols. Optionally, specify the currency ("USD" or "INR") and a maximum price (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description:
            'Array of cryptocurrency symbols like ["BTC", "ETH"] for Bitcoin and Ethereum.',
        },
        currency: {
          type: 'string',
          enum: ['USD', 'INR'],
          description:
            'Currency for the price. Default is USD. For INR conversion, use "INR".',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter cryptos with current price under this value (in the specified currency).',
        },
      },
      required: ['symbols'],
    },
  },
  {
    name: 'get_top_stocks',
    description:
      'Get the trending Indian stocks in real time using NSE data. Optionally, specify a price filter (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top stocks to fetch (default is 5).',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter stocks with price under this value (in INR).',
        },
      },
    },
  },
  {
    name: 'get_top_cryptos',
    description:
      'Get the trending cryptocurrencies in real time. Optionally, specify the currency ("USD" or "INR") and a price filter (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top cryptos to fetch (default is 5).',
        },
        currency: {
          type: 'string',
          enum: ['USD', 'INR'],
          description:
            'Currency for the price. Default is USD. For INR conversion, use "INR".',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter cryptos with current price under this value (in the specified currency).',
        },
      },
    },
  },
  {
    name: 'get_company_info',
    description: 'Get information about Profit Flow company and services',
    parameters: {
      type: 'object',
      properties: {
        category: {
          type: 'string',
          enum: [
            'all',
            'features',
            'pricing',
            'benefits',
            'support',
            'faq',
            'subscription',
          ],
          description: 'Category of information requested',
        },
      },
    },
  },
  {
    name: 'get_market_update',
    description:
      'Get a comprehensive update of the Indian stock market that includes trending NSE stocks and current market news.',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top stocks to fetch (default is 5).',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter stocks with price under this value (in INR).',
        },
      },
    },
  },
  {
    name: 'get_crypto_market_update',
    description:
      'Get a comprehensive update of the cryptocurrency market that includes trending cryptocurrencies and current crypto market news.',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top cryptocurrencies to fetch (default is 5).',
        },
        currency: {
          type: 'string',
          enum: ['USD', 'INR'],
          description:
            'Currency for the price. Default is USD. For INR conversion, use "INR".',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter cryptocurrencies with current price under this value (in the specified currency).',
        },
      },
    },
  },
];

/**
 * Helper: Fetch realtime data for a ticker.
 */
async function fetchRealtimeData(ticker) {
  try {
    const quote = await yahooFinance.quote(ticker);
    if (!quote) return null;
    const now = new Date().toISOString();
    return { dates: [now], prices: [quote.regularMarketPrice] };
  } catch (error) {
    console.error(`Error fetching realtime data for ${ticker}:`, error);
    return null;
  }
}

/**
 * Helper: Fetch historical data for a ticker.
 */
async function fetchHistoricalData(ticker, period1, period2, interval = '1d') {
  try {
    const historical = await yahooFinance.historical(ticker, { period1, period2, interval });
    return historical.map(item => ({
      date: item.date,
      price: item.close,
    }));
  } catch (error) {
    console.error(`Error fetching historical data for ${ticker}:`, error);
    return [];
  }
}

/**
 * Helper: Fetch detailed info for a ticker.
 */
async function fetchDetailedInfo(ticker) {
  try {
    const detailedInfo = await yahooFinance.quoteSummary(ticker, {
      modules: ['summaryDetail', 'summaryProfile', 'assetProfile']
    });
    return detailedInfo;
  } catch (error) {
    console.error(`Error fetching detailed info for ${ticker}:`, error);
    return null;
  }
}

/**
 * Helper: Fetch recent news for a ticker.
 */
async function fetchNews(ticker) {
  try {
    const searchResult = await yahooFinance.search(`${ticker} news`, { lang: 'en-IN', region: 'IN' });
    let news = searchResult.news || [];
    if (!news.length) {
      console.warn(`No news found for ${ticker}, fetching general market news.`);
      news = await fetchMarketNews();
    }
    return news;
  } catch (error) {
    console.error(`Error fetching news for ${ticker}:`, error);
    return [];
  }
}

/**
 * New Helper: Fetch general market news.
 */
async function fetchMarketNews() {
  try {
    const searchResult = await yahooFinance.search("Indian stock market", { lang: 'en-IN', region: 'IN' });
    return searchResult.news || [];
  } catch (error) {
    console.error("Error fetching market news:", error);
    return [];
  }
}

/**
 * New Helper: Fetch crypto market news.
 */
async function fetchCryptoMarketNews() {
  try {
    const searchResult = await yahooFinance.search("cryptocurrency market news", { lang: 'en-IN', region: 'IN' });
    return searchResult.news || [];
  } catch (error) {
    console.error("Error fetching crypto market news:", error);
    return [];
  }
}

/**
 * Fetch real-time stock data for Indian stocks.
 */
async function getStockPrice(symbols, underPrice) {
  const results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

  for (let symbol of symbols) {
    try {
      let querySymbol = symbol;
      if (!symbol.includes('.') && /^[A-Z]+$/.test(symbol)) {
        querySymbol = `${symbol}.NS`;
      }
      const quote = await yahooFinance.quote(querySymbol);
      const rtData = await fetchRealtimeData(querySymbol);
      if (!rtData) {
        results.push({ symbol, error: 'No real-time data available' });
        continue;
      }
      const history = await fetchHistoricalData(querySymbol, past7Days, now, '1d');
      const detailedInfo = await fetchDetailedInfo(querySymbol);
      const news = await fetchNews(querySymbol);

      results.push({
        symbol: querySymbol,
        name: quote.longName || symbol,
        dates: rtData.dates,
        prices: rtData.prices,
        history,
        change: quote.regularMarketChange,
        changePercentage: quote.regularMarketChangePercent,
        marketCap: quote.marketCap,
        detailedInfo,
        news
      });
    } catch (error) {
      console.error(`Error fetching stock price for ${symbol}:`, error);
      results.push({ symbol, error: 'Unable to fetch data' });
    }
  }
  if (underPrice !== undefined) {
    return results.filter((r) => r.prices[0] < underPrice);
  }
  return results;
}

/**
 * Fetch trending (top) Indian stocks in real time.
 */
async function getTopStocks(limit = 5, underPrice) {
  let results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

  try {
    const cookieResponse = await axios.get('https://www.nseindia.com', {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
        'Accept-Language': 'en-US,en;q=0.9'
      }
    });
    const cookies = cookieResponse.headers['set-cookie'];
    const cookieHeader = cookies ? cookies.join('; ') : '';

    const nseResponse = await axios.get(
      'https://www.nseindia.com/api/live-analysis-variations?index=gainers',
      {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
          'Accept': 'application/json',
          'Accept-Language': 'en-US,en;q=0.9',
          'Referer': 'https://www.nseindia.com/',
          'Cookie': cookieHeader,
        },
      }
    );
    const trendingData = nseResponse.data?.NIFTY?.data;
    if (!trendingData || trendingData.length === 0) {
      throw new Error('No trending data available from NSE API');
    }
    const symbols = trendingData
      .map((item) => item.symbol)
      .slice(0, limit)
      .map((sym) => (sym.includes('.') ? sym : sym + '.NS'));
    for (const symbol of symbols) {
      try {
        const quote = await yahooFinance.quote(symbol);
        const rtData = await fetchRealtimeData(symbol);
        if (!rtData) continue;
        const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
        const detailedInfo = await fetchDetailedInfo(symbol);
        const news = await fetchNews(symbol);
        results.push({
          symbol,
          name: quote.longName || symbol,
          dates: rtData.dates,
          prices: rtData.prices,
          history,
          change: quote.regularMarketChange,
          changePercentage: quote.regularMarketChangePercent,
          marketCap: quote.marketCap,
          detailedInfo,
          news
        });
      } catch (err) {
        console.error(`Error fetching realtime data for ${symbol}:`, err);
      }
    }
  } catch (error) {
    console.error('Error fetching top stocks from NSE:', error);
    return { error: 'Unable to fetch trending Indian stocks from NSE.' };
  }
  if (underPrice !== undefined) {
    results = results.filter((r) => r.prices[0] < underPrice);
  }
  return results;
}

/**
 * Fetch real-time cryptocurrency data.
 */
async function getCryptoPrice(symbols, currency = 'USD', underPrice) {
  let conversionRate = 1;
  if (currency === 'INR') {
    try {
      const rateQuote = await yahooFinance.quote('USDINR=X');
      conversionRate = rateQuote.regularMarketPrice || 1;
    } catch (error) {
      console.error('Error fetching conversion rate:', error);
    }
  }
  const results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  for (let symbol of symbols) {
    try {
      if (!symbol.includes('-')) {
        symbol = `${symbol}-USD`;
      }
      const quote = await yahooFinance.quote(symbol);
      const rtData = await fetchRealtimeData(symbol);
      if (!rtData) {
        results.push({ symbol, error: 'No real-time data available' });
        continue;
      }
      let price = rtData.prices[0];
      if (currency === 'INR') {
        price = price * conversionRate;
      }
      const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
      let detailedInfo = null;
      let news = [];
      try {
        detailedInfo = await fetchDetailedInfo(symbol);
        news = await fetchNews(symbol);
      } catch (err) {
        console.error(`Error fetching detailed info or news for ${symbol}:`, err);
      }
      results.push({
        symbol,
        name: quote.shortName || symbol,
        dates: rtData.dates,
        prices: [price],
        history,
        change: quote.regularMarketChange,
        changePercentage: quote.regularMarketChangePercent,
        marketCap: quote.marketCap,
        detailedInfo,
        news,
      });
    } catch (error) {
      console.error(`Error fetching crypto price for ${symbol}:`, error);
      results.push({ symbol, error: 'Unable to fetch data' });
    }
  }
  if (underPrice !== undefined) {
    const filtered = results.filter((r) => r.prices[0] < underPrice);
    return filtered.length > 0 ? filtered : [{ message: `No cryptocurrencies found with a price under ${underPrice}.` }];
  }
  return results;
}

/**
 * Fetch trending (top) cryptocurrencies in real time.
 */
async function getTopCryptos(limit = 5, currency = 'USD', underPrice) {
  let conversionRate = 1;
  if (currency === 'INR') {
    try {
      const rateQuote = await yahooFinance.quote('USDINR=X');
      conversionRate = rateQuote.regularMarketPrice || 1;
    } catch (error) {
      console.error('Error fetching conversion rate:', error);
    }
  }
  try {
    const response = await fetch(
      `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${limit}&page=1`
    );
    const coins = await response.json();
    if (!coins || !coins.length) {
      throw new Error('Failed to fetch top cryptocurrencies');
    }
    let results = [];
    const now = new Date();
    const past7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    for (const coin of coins) {
      const symbol = `${coin.symbol.toUpperCase()}-USD`;
      try {
        const quote = await yahooFinance.quote(symbol);
        const rtData = await fetchRealtimeData(symbol);
        if (!rtData) continue;
        let price = rtData.prices[0];
        if (currency === 'INR') {
          price = price * conversionRate;
        }
        const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
        results.push({
          symbol,
          name: quote.shortName || coin.name,
          dates: rtData.dates,
          prices: [price],
          history,
          change: quote.regularMarketChange,
          changePercentage: quote.regularMarketChangePercent,
          marketCap: quote.marketCap,
        });
      } catch (err) {
        console.error(`Error processing ${symbol}:`, err);
      }
    }
    if (underPrice !== undefined) {
      results = results.filter((r) => r.prices[0] < underPrice);
      return results.length > 0 ? results : [{ message: `No cryptocurrencies found with a price under ${underPrice}.` }];
    }
    return results;
  } catch (error) {
    console.error('Error fetching top cryptos:', error);
    return { error: 'Unable to fetch top cryptos' };
  }
}

/**
 * New Function: Fetch crypto market update.
 */
async function getCryptoMarketUpdate(limit = 2, currency = 'USD', underPrice) {
  const topCryptos = await getTopCryptos(limit, currency, underPrice);
  const cryptoNews = await fetchCryptoMarketNews();
  return {
    topCryptos,
    newsHighlights: cryptoNews.slice(0, 5)
  };
}

/**
 * New Function: Fetch market update.
 */
async function getMarketUpdate(limit = 2, underPrice) {
  const topStocks = await getTopStocks(limit, underPrice);
  const marketNews = await fetchMarketNews();
  return {
    topStocks,
    newsHighlights: marketNews.slice(0, 5)
  };
}

/**
 * Fetch company information from MongoDB Atlas.
 */
async function getCompanyInfo(args) {
  let category = args?.category || 'all';
  if (category === 'subscription') {
    category = 'pricing';
  }
  const companyDoc = await CompanyInfo.findOne({ name: 'Profit Flow' }).lean();
  if (!companyDoc) {
    throw new Error('Company information not found in the database.');
  }
  return category === 'all' ? companyDoc : { [category]: companyDoc[category] };
}

export async function POST(request) {
  try {
    const { messages } = await request.json();

    // Call OpenAI to get the initial assistant response.
    const initialResponse = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content:
            'You are a highly specialized financial analyst assistant focused exclusively on Indian stocks and crypto analysis. Provide responses in structured markdown format with clear bullet points, proper spacing between topics, and dynamic chart headings based on the query. Respond in a professional tone and include relevant suggestions when applicable. If a user asks about stocks outside of India, still provide Indian stock data only.',
        },
        ...messages,
      ],
      functions,
      function_call: 'auto',
    });
    const message = initialResponse.choices[0].message;

    // If OpenAI requested a function call, process that.
    if (message.function_call) {
      const functionName = message.function_call.name;
      const args = JSON.parse(message.function_call.arguments || '{}');
      let functionResponse;

      // Dispatch to the appropriate helper function.
      switch (functionName) {
        case 'get_stock_price':
          functionResponse = await getStockPrice(args.symbols, args.underPrice);
          break;
        case 'get_top_stocks':
          functionResponse = await getTopStocks(args.limit || 2, args.underPrice);
          break;
        case 'get_crypto_price':
          functionResponse = await getCryptoPrice(args.symbols, args.currency || 'USD', args.underPrice);
          break;
        case 'get_top_cryptos':
          functionResponse = await getTopCryptos(args.limit || 2, args.currency || 'USD', args.underPrice);
          break;
        case 'get_company_info':
          functionResponse = await getCompanyInfo(args);
          break;
        case 'get_market_update':
          functionResponse = await getMarketUpdate(args.limit || 2, args.underPrice);
          break;
        case 'get_crypto_market_update':
          functionResponse = await getCryptoMarketUpdate(args.limit || 2, args.currency || 'USD', args.underPrice);
          break;
        default:
          functionResponse = { error: 'Function not supported' };
      }

      // Generate the final assistant response.
      let finalResponse;
      if (functionName === 'get_company_info') {
        finalResponse = await openai.chat.completions.create({
          model: 'gpt-4o',
          messages: [
            ...messages,
            {
              role: 'system',
              content:
                'You are a friendly advisor providing company information. Keep your response clear, concise, and conversational. Limit your answer to under three paragraphs and include any offers naturally.',
            },
            {
              role: 'user',
              content: `Company Data:\n${JSON.stringify(functionResponse, null, 2)}`,
            },
          ],
          temperature: 0.7,
          max_tokens: 500,
        });
      } else {
        const responseTemplate = `Please generate a creative and professional financial update using the data provided below.
Data:
${JSON.stringify(functionResponse, null, 2)}

Ensure your response is engaging, well-structured, and adapts to the query context without using tables.`;
        finalResponse = await openai.chat.completions.create({
          model: 'gpt-4o',
          messages: [
            ...messages,
            {
              role: 'system',
              content:
                'You are a highly specialized financial analyst assistant focused exclusively on Indian stocks and crypto analysis. Provide responses in structured markdown format with clear bullet points, proper spacing between topics, and dynamic chart headings based on the query. Respond in a professional tone and include relevant suggestions when applicable. If a user asks about stocks outside of India, still provide Indian stock data only.',
            },
            {
              role: 'user',
              content: responseTemplate,
            },
          ],
          temperature: 0.6,
          max_tokens: 1000,
        });
      }

      return NextResponse.json({
        ...finalResponse.choices[0].message,
        rawData: functionResponse,
        functionName: message.function_call.name,
      });
    } else {
      return NextResponse.json({
        role: 'assistant',
        content:
          message.content || "I'm here to help! Could you please clarify your request?",
      });
    }
  } catch (error) {
    console.error('API Error:', error);
    return NextResponse.json(
      {
        error: 'Financial data currently unavailable. Please try again later.',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined,
      },
      { status: 500 }
    );
  }
}






















import { NextResponse } from 'next/server';
import mongoose from 'mongoose';
import UserChatLog from '@/src/models/UserChatLog';
import dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

const MONGODB_URI = process.env.MONGODB_URI;

// Connect to MongoDB (ensure that you are not reconnecting on every request)
if (!mongoose.connection.readyState) {
  mongoose.connect(MONGODB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
}

export async function POST(request) {
  try {
    const { userId, messages } = await request.json();

    // Update or create document with the given userId
    await UserChatLog.findOneAndUpdate(
      { userId },
      { $push: { messages: { $each: messages } } },
      { upsert: true, new: true }
    );

    return NextResponse.json({ message: 'Chat log updated successfully' });
  } catch (error) {
    console.error('Error saving chat log:', error);
    return NextResponse.json(
      { error: 'Failed to save chat log', details: error.message },
      { status: 500 }
    );
  }
}










































import { NextResponse } from 'next/server';
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import UserChatLog from '@/src/models/UserChatLog';

dotenv.config({ path: '.env.local' });

const MONGODB_URI = process.env.MONGODB_URI;

// Connect to MongoDB if not already connected.
if (!mongoose.connection.readyState) {
  mongoose
    .connect(MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    })
    .then(() => console.log('Connected to MongoDB Atlas'))
    .catch((err) => console.error('MongoDB connection error:', err));
}

export async function PUT(request) {
  try {
    // Default userId to 'static-user-123' if not provided.
    const { userId = 'static-user-123', messageId, action, reportMessage } = await request.json();
    console.log("Received feedback update:", { userId, messageId, action, reportMessage });

    // Validate that the action is allowed.
    if (!['like', 'dislike', 'report'].includes(action)) {
      return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
    }

    // Build the update object based on the action.
    const update = {};
    if (action === 'like') {
      update["messages.$.actions.like"] = true;
      update["messages.$.actions.dislike"] = false;
    } else if (action === 'dislike') {
      update["messages.$.actions.dislike"] = true;
      update["messages.$.actions.like"] = false;
    } else if (action === 'report') {
      update["messages.$.actions.report"] = true;
      update["messages.$.actions.reportMessage"] = reportMessage || "";
    }

    // Use the positional operator "$" to update the matching message in the messages array.
    const result = await UserChatLog.updateOne(
      { userId, "messages.messageId": messageId },
      { $set: update }
    );

    if (result.modifiedCount === 0) {
      return NextResponse.json({ error: 'Message not found or feedback not updated' }, { status: 404 });
    }

    return NextResponse.json({ message: 'Feedback updated successfully', messageId });
  } catch (error) {
    console.error('Feedback API error:', error);
    return NextResponse.json(
      { error: 'Failed to update feedback', details: error.message },
      { status: 500 }
    );
  }
}







































"use client";
import React, { useState, useRef, useEffect } from 'react';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import {
  Box,
  TextField,
  CircularProgress,
  Typography,
  IconButton,
  Grid,
  ToggleButton,
  ToggleButtonGroup,
  Button,
  Tooltip,
} from '@mui/material';
import {
  Send as SendIcon,
  ThumbUpAltOutlined,
  ThumbDownAltOutlined,
  FlagOutlined,
  Check,
  ContentCopy,
} from '@mui/icons-material';
// Import filled variants:
import ThumbUpAlt from '@mui/icons-material/ThumbUpAlt';
import ThumbDownAlt from '@mui/icons-material/ThumbDownAlt';
import Flag from '@mui/icons-material/Flag';

import ReactMarkdown from 'react-markdown';
import { styled, keyframes } from '@mui/material/styles';
import { Line, Bar } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title as ChartTitle,
  Tooltip as ChartTooltip,
  Legend,
} from 'chart.js';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ChartTitle,
  ChartTooltip,
  Legend
);

const fadeIn = keyframes`
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
`;

const ChatContainer = styled(Box)(({ theme }) => ({
  height: '80vh',
  display: 'flex',
  flexDirection: 'column',
  backgroundColor: 'transparent',
  color: '#fff',
  borderRadius: theme.shape.borderRadius,
  padding: theme.spacing(2),
  overflow: 'hidden',
}));

const QuestionBox = styled(Box)(({ theme }) => ({
  alignSelf: 'flex-end',
  background: 'linear-gradient(45deg, #2196f3 30%, #21cbf3 90%)',
  color: '#fff',
  borderRadius: '20px 20px 20px 0',
  padding: theme.spacing(1.5),
  marginBottom: theme.spacing(1),
  display: 'inline-block',
  animation: `${fadeIn} 0.5s ease-out`,
}));

const AnswerText = styled(Box)(({ theme }) => ({
  alignSelf: 'flex-start',
  padding: theme.spacing(1.5),
  marginBottom: theme.spacing(2),
  maxWidth: '100%',
  lineHeight: 1.8,
  animation: `${fadeIn} 0.5s ease-out`,
  '& a': {
    color: '#2196f3 !important',
    textDecoration: 'underline',
    fontWeight: 500,
    transition: 'all 0.2s ease-in-out',
    '&:hover': {
      color: '#1976d2 !important',
      textDecoration: 'none !important',
    },
  },
}));

const ChartContainerWrapper = styled(Box)(({ theme }) => ({
  marginTop: theme.spacing(2),
  marginBottom: theme.spacing(2),
}));

const ChartDisplay = ({ chartData, chartType, chartTitle }) => {
  const adjustedData = JSON.parse(JSON.stringify(chartData));
  if (chartType === 'bar') {
    adjustedData.datasets.forEach((dataset) => {
      delete dataset.tension;
      dataset.fill = true;
    });
  }
  const commonOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'top',
        labels: { color: '#fff' },
      },
      title: {
        display: true,
        text: chartTitle,
        color: '#fff',
        font: { size: 16 },
      },
    },
    scales: {
      x: {
        ticks: { color: '#fff' },
        grid: { color: 'rgba(255,255,255,0.2)' },
        title: {
          display: true,
          text:
            (chartData.labels &&
              chartData.labels[0] &&
              (chartData.labels[0].includes('-') || chartData.labels[0].includes('/')))
              ? 'Time'
              : 'Symbol',
          color: '#fff',
        },
      },
      y: {
        ticks: { color: '#fff' },
        grid: { color: 'rgba(255,255,255,0.2)' },
        title: { display: true, text: 'Price (USD)', color: '#fff' },
      },
    },
  };

  return chartType === 'line' ? (
    <Line data={chartData} options={commonOptions} />
  ) : (
    <Bar data={adjustedData} options={commonOptions} />
  );
};

const markdownComponents = {
  p: ({ node, ...props }) => (
    <p style={{ textAlign: 'justify', textIndent: '1em' }} {...props} />
  ),
  h1: ({ node, ...props }) => (
    <h1
      style={{
        margin: '1.2em 0 0.5em',
        paddingBottom: '0.3em',
        fontWeight: 'bold',
        textAlign: 'justify',
      }}
      {...props}
    />
  ),
  h2: ({ node, ...props }) => (
    <h2
      style={{
        margin: '1.2em 0 0.5em',
        paddingBottom: '0.3em',
        fontWeight: 'bold',
        textAlign: 'justify',
      }}
      {...props}
    />
  ),
  h3: ({ node, ...props }) => (
    <h3 style={{ margin: '1em 0 0.5em', fontWeight: 'bold', textAlign: 'justify' }} {...props} />
  ),
  li: ({ node, ordered, ...props }) => (
    <li style={{ marginBottom: '0.5em', marginLeft: '1em', textAlign: 'justify' }} {...props} />
  ),
  blockquote: ({ node, ...props }) => (
    <blockquote
      style={{
        borderLeft: '4px solid #4bd8d8',
        margin: '1em 0',
        paddingLeft: '1em',
        fontStyle: 'italic',
        color: '#ccc',
        textAlign: 'justify',
      }}
      {...props}
    />
  ),
  a: ({ node, ...props }) => (
    <a target="_blank" rel="noopener noreferrer" {...props} />
  ),
};

// -------------------- Updated IconWrapper --------------------
// This wrapper forces white icons by default and applies filled background styling.
const UpdatedIconWrapper = styled(IconButton, {
  shouldForwardProp: (prop) => prop !== 'active',
})(({ theme, active }) => ({
  color: active ? theme.palette.primary.contrastText : '#fff',
  backgroundColor: active ? theme.palette.primary.main : 'transparent',
  '&:hover': {
    backgroundColor: active ? theme.palette.primary.dark : 'rgba(255,255,255,0.1)',
  },
}));

// -------------------- FeedbackButtons Component --------------------
const FeedbackButtons = ({ messageId, content }) => {
  const [feedback, setFeedback] = useState(null);
  const [reportText, setReportText] = useState('');
  const [showReportPopup, setShowReportPopup] = useState(false);
  const [copied, setCopied] = useState(false);

  const sendFeedback = async (action, reportMsg = '') => {
    try {
      await axios.put('/api/feedback', {
        messageId,
        action,
        reportMessage: reportMsg,
      });
      setFeedback(action);
    } catch (error) {
      console.error('Error updating feedback:', error);
    }
  };

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(content);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy text: ', err);
    }
  };

  return (
    <Box sx={{ mt: 1, display: 'flex', alignItems: 'center', gap: 0.5 }}>
      {/* Copy Button */}
      <Tooltip title={copied ? "Copied!" : "Copy"}>
        <UpdatedIconWrapper onClick={handleCopy} size="small">
          {copied ? <Check fontSize="small" /> : <ContentCopy fontSize="small" />}
        </UpdatedIconWrapper>
      </Tooltip>

      {/* Like Button */}
      <Tooltip title="Like">
        <UpdatedIconWrapper
          onClick={() => sendFeedback('like')}
          size="small"
          active={feedback === 'like'}
          sx={{ display: (feedback === 'dislike' || feedback === 'report') ? 'none' : 'inline-flex' }}
        >
          {feedback === 'like' ? (
            <ThumbUpAlt fontSize="small" />
          ) : (
            <ThumbUpAltOutlined fontSize="small" />
          )}
        </UpdatedIconWrapper>
      </Tooltip>

      {/* Dislike Button */}
      <Tooltip title="Dislike">
        <UpdatedIconWrapper
          onClick={() => sendFeedback('dislike')}
          size="small"
          active={feedback === 'dislike'}
          sx={{ display: (feedback === 'like' || feedback === 'report') ? 'none' : 'inline-flex' }}
        >
          {feedback === 'dislike' ? (
            <ThumbDownAlt fontSize="small" />
          ) : (
            <ThumbDownAltOutlined fontSize="small" />
          )}
        </UpdatedIconWrapper>
      </Tooltip>

      {/* Report Button */}
      <Tooltip title="Report">
        <UpdatedIconWrapper
          onClick={() => setShowReportPopup(true)}
          size="small"
          active={feedback === 'report'}
          sx={{ display: feedback === 'like' ? 'none' : 'inline-flex' }}
        >
          {feedback === 'report' ? (
            <Flag fontSize="small" />
          ) : (
            <FlagOutlined fontSize="small" />
          )}
        </UpdatedIconWrapper>
      </Tooltip>

      {/* Report Dialog */}
      {showReportPopup && (
        <Box
          sx={{
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            backgroundColor: '#1e1e1e',
            p: 3,
            zIndex: 1000,
            borderRadius: 2,
            boxShadow: '0px 4px 20px rgba(0,0,0,0.5)',
            width: '90%',
            maxWidth: '500px',
            border: '1px solid #2196f3',
          }}
        >
          <Typography variant="subtitle1" sx={{ mb: 2, color: '#fff' }}>
            Report Issue
          </Typography>
          <TextField
            fullWidth
            multiline
            rows={4}
            value={reportText}
            onChange={(e) => setReportText(e.target.value)}
            placeholder="Please describe the issue you encountered..."
            sx={{
              '& .MuiInputBase-root': {
                color: '#fff',
                backgroundColor: 'rgba(255,255,255,0.1)',
                borderRadius: 1,
                '&:hover fieldset': { borderColor: '#2196f3' },
                '&.Mui-focused fieldset': { borderColor: '#2196f3' },
              },
            }}
          />
          <Box sx={{ mt: 2, display: 'flex', justifyContent: 'flex-end', gap: 1 }}>
            <Button
              variant="outlined"
              onClick={() => setShowReportPopup(false)}
              sx={{
                color: '#fff',
                borderColor: '#444',
                '&:hover': { borderColor: '#2196f3' },
              }}
            >
              Cancel
            </Button>
            <Button
              variant="contained"
              onClick={() => {
                sendFeedback('report', reportText);
                setShowReportPopup(false);
              }}
              sx={{
                background: 'linear-gradient(45deg, #2196f3 30%, #21cbf3 90%)',
                '&:hover': { opacity: 0.9 },
              }}
            >
              Submit
            </Button>
          </Box>
        </Box>
      )}
    </Box>
  );
};

// -------------------- End FeedbackButtons --------------------

export default function Chat() {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [chartType, setChartType] = useState('line');
  const messagesEndRef = useRef(null);

  const defaultQuestions = ['top 2 stocks', 'price of infosys stock'];

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    console.log(messages);
    if (messages.length > 0) {
      axios.post('/api/chatlog', {
        userId: 'static-user-123',
        messages: messages,
      }).catch(error => {
        console.error('Error updating chat log:', error);
      });
    }
  }, [messages]);

  const sendMessage = async (messageContent) => {
    if (!messageContent.trim() || loading) return;
    setLoading(true);

    // Generate a unique messageId for the user message.
    const userMessage = { messageId: uuidv4(), role: 'user', content: messageContent };
    setMessages((prev) => [...prev, userMessage]);

    try {
      const { data } = await axios.post('/api/chat', {
        messages: [...messages, userMessage],
      });
      // Ensure the assistant message includes a messageId.
      const assistantMessage = { ...data, messageId: data.messageId || uuidv4() };

      // Process rawData for chartData if available.
      if (assistantMessage.rawData && assistantMessage.rawData.length > 0) {
        let chartData;
        let chartTitle = '';

        if (assistantMessage.rawData[0].history && assistantMessage.rawData[0].history.length > 0) {
          const labels = assistantMessage.rawData[0].history.map((item) =>
            new Date(item.date).toLocaleDateString()
          );
          const datasets = assistantMessage.rawData.map((asset, index) => ({
            label: asset.symbol || asset.name || `Asset ${index + 1}`,
            data: asset.history.map((item) => item.price),
            fill: false,
            borderColor: `hsl(${(index * 360) / assistantMessage.rawData.length}, 70%, 50%)`,
            backgroundColor: `hsl(${(index * 360) / assistantMessage.rawData.length}, 70%, 50%)`,
            tension: 0.1,
          }));
          chartData = { labels, datasets };
          chartTitle = `${assistantMessage.rawData.map((item) => item.symbol).join(' & ')} Price History`;
        } else if (assistantMessage.rawData[0].dates && assistantMessage.rawData[0].prices) {
          if (assistantMessage.rawData[0].prices.length > 1) {
            chartData = {
              labels: assistantMessage.rawData[0].dates,
              datasets: assistantMessage.rawData.map((item, index) => ({
                label: item.symbol || 'Price',
                data: item.prices,
                fill: false,
                borderColor: `hsl(${(index * 360) / assistantMessage.rawData.length}, 70%, 50%)`,
                backgroundColor: `hsl(${(index * 360) / assistantMessage.rawData.length}, 70%, 50%)`,
                tension: 0.1,
              })),
            };
            chartTitle = `${assistantMessage.rawData.map((item) => item.symbol).join(' & ')} Price History`;
          } else {
            chartData = {
              labels: assistantMessage.rawData.map((item, index) => item.symbol || `Asset ${index + 1}`),
              datasets: [
                {
                  label: 'Current Price',
                  data: assistantMessage.rawData.map((item) => item.prices[0]),
                  backgroundColor: assistantMessage.rawData.map(
                    (_, index) => `hsl(${(index * 360) / assistantMessage.rawData.length}, 70%, 50%)`
                  ),
                  borderColor: assistantMessage.rawData.map(
                    (_, index) => `hsl(${(index * 360) / assistantMessage.rawData.length}, 70%, 50%)`
                  ),
                  borderWidth: 1,
                },
              ],
            };
            chartTitle = `${assistantMessage.rawData.map((item) => item.symbol).join(' & ')} Current Price`;
          }
        }
        assistantMessage.chartData = chartData;
        assistantMessage.chartTitle = chartTitle;
      }

      // Append the assistant message (now with messageId) to messages.
      setMessages((prev) => [...prev, assistantMessage]);
    } catch (error) {
      console.error("Client-side error:", error);
      setMessages((prev) => [
        ...prev,
        { role: '⚠️', content: "I encountered an error. Please try again or ask about financial topics." },
      ]);
    } finally {
      setLoading(false);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    const messageToSend = input;
    setInput('');
    await sendMessage(messageToSend);
  };

  const handleExampleClick = (example) => {
    sendMessage(example);
  };

  const handleChartType = (event, newType) => {
    if (newType !== null) {
      setChartType(newType);
    }
  };

  return (
    <Box
      sx={{
        maxWidth: '800px',
        mx: 'auto',
        p: 2,
        height: '100vh',
        display: 'flex',
        flexDirection: 'column',
        backgroundColor: 'transparent',
        color: '#fff',
      }}
    >
      <Typography variant="h5" sx={{ mb: 3, fontWeight: 300, textAlign: 'center' }}>
        PROFIT FLOW
      </Typography>

      {messages.length === 0 && (
        <Box sx={{ mb: 2, display: 'flex', gap: 2, justifyContent: 'center' }}>
          {defaultQuestions.map((question, idx) => (
            <Button
              key={idx}
              variant="contained"
              onClick={() => handleExampleClick(question)}
              sx={{
                borderRadius: '20px',
                background: 'linear-gradient(45deg, #2196f3 30%, #21cbf3 90%)',
                color: '#fff',
                textTransform: 'none',
                fontWeight: 600,
                boxShadow: '0px 3px 5px -1px rgba(0,0,0,0.2)',
                '&:hover': {
                  background: 'linear-gradient(45deg, #21cbf3 30%, #2196f3 90%)',
                },
              }}
            >
              {question}
            </Button>
          ))}
        </Box>
      )}

      <ChatContainer>
        <Box
          sx={{
            flex: 1,
            overflowY: 'auto',
            pb: 1,
            scrollbarWidth: 'none',
            '&::-webkit-scrollbar': { display: 'none' },
          }}
        >
          {messages.map((msg, i) =>
            msg.role === 'user' ? (
              <QuestionBox key={i}>
                <ReactMarkdown components={markdownComponents}>{msg.content}</ReactMarkdown>
              </QuestionBox>
            ) : (
              <AnswerText key={i}>
                <ReactMarkdown components={markdownComponents}>
                  {msg.content || 'Fetching real-time data...'}
                </ReactMarkdown>
                {msg.chartData && (
                  <ChartContainerWrapper>
                    <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 1 }}>
                      <ToggleButtonGroup
                        value={chartType}
                        exclusive
                        onChange={handleChartType}
                        size="small"
                        sx={{
                          '& .MuiToggleButton-root': {
                            color: '#fff',
                            borderColor: '#444',
                            backgroundColor: 'transparent',
                          },
                          '& .Mui-selected': {
                            backgroundColor: '#444 !important',
                            color: '#fff',
                          },
                        }}
                      >
                        <ToggleButton value="line">Line</ToggleButton>
                        <ToggleButton value="bar">Bar</ToggleButton>
                      </ToggleButtonGroup>
                    </Box>
                    <Box sx={{ width: '100%', height: '400px' }}>
                      <ChartDisplay
                        chartData={msg.chartData}
                        chartType={chartType}
                        chartTitle={msg.chartTitle}
                      />
                    </Box>
                  </ChartContainerWrapper>
                )}
                {/* Render feedback buttons using the messageId */}
                <FeedbackButtons messageId={msg.messageId} content={msg.content} />
              </AnswerText>
            )
          )}
          {loading && (
            <AnswerText>
              <Grid container spacing={1} alignItems="center">
                <Grid item>
                  <CircularProgress size={20} sx={{ color: '#fff' }} />
                </Grid>
              </Grid>
            </AnswerText>
          )}
          <div ref={messagesEndRef} />
        </Box>

        <Box
          component="form"
          onSubmit={handleSubmit}
          sx={{
            mt: 2,
            display: 'flex',
            gap: 1,
          }}
        >
          <TextField
            fullWidth
            variant="outlined"
            size="small"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Ask for stock/crypto price"
            sx={{
              '& .MuiOutlinedInput-root': {
                backgroundColor: '#1e1e1e',
                borderRadius: '8px',
                border: '1px solid #2196f3',
                '& fieldset': { borderColor: '#2196f3' },
                '&:hover fieldset': { borderColor: '#fff' },
                '&.Mui-focused fieldset': { borderColor: '#fff' },
              },
              input: { color: '#fff' },
            }}
            InputProps={{
              endAdornment: (
                <IconButton type="submit" color="primary" disabled={loading}>
                  <SendIcon />
                </IconButton>
              ),
            }}
          />
        </Box>
      </ChatContainer>
    </Box>
  );
}






























// src/app/api/chat/route.js

import { NextResponse } from 'next/server';
import OpenAI from 'openai';
import mongoose from 'mongoose';
import CompanyInfo from '@/src/models/CompanyInfo';
import dotenv from 'dotenv';
import yahooFinance from 'yahoo-finance2';
import UserChatLog from '@/src/models/UserChatLog';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';

dotenv.config({ path: '.env.local' });

const MONGODB_URI = process.env.MONGODB_URI;

// Reuse MongoDB connection in a serverless environment
if (!mongoose.connection.readyState) {
  mongoose
    .connect(MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    })
    .then(() => console.log('Connected to MongoDB Atlas'))
    .catch((err) => console.error('MongoDB connection error:', err));
}

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

const functions = [
  {
    name: 'get_stock_price',
    description:
      'Get real-time stock price (current quote), historical price data, and basic information for one or more stock symbols. This function always returns data for Indian stocks only.',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description:
            'Array of stock symbols like ["RELIANCE", "TCS"] for Reliance and TCS.',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter stocks with current price under this value (in INR).',
        },
      },
      required: ['symbols'],
    },
  },
  {
    name: 'get_crypto_price',
    description:
      'Get real-time cryptocurrency price (current quote), historical price data, and basic information for one or more crypto symbols. Optionally, specify the currency ("USD" or "INR") and a maximum price (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description:
            'Array of cryptocurrency symbols like ["BTC", "ETH"] for Bitcoin and Ethereum.',
        },
        currency: {
          type: 'string',
          enum: ['USD', 'INR'],
          description:
            'Currency for the price. Default is USD. For INR conversion, use "INR".',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter cryptos with current price under this value (in the specified currency).',
        },
      },
      required: ['symbols'],
    },
  },
  {
    name: 'get_top_stocks',
    description:
      'Get the trending Indian stocks in real time using NSE data. Optionally, specify a price filter (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top stocks to fetch (default is 5).',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter stocks with price under this value (in INR).',
        },
      },
    },
  },
  {
    name: 'get_top_cryptos',
    description:
      'Get the trending cryptocurrencies in real time. Optionally, specify the currency ("USD" or "INR") and a price filter (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top cryptos to fetch (default is 5).',
        },
        currency: {
          type: 'string',
          enum: ['USD', 'INR'],
          description:
            'Currency for the price. Default is USD. For INR conversion, use "INR".',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter cryptos with current price under this value (in the specified currency).',
        },
      },
    },
  },
  {
    name: 'get_company_info',
    description: 'Get information about Profit Flow company and services',
    parameters: {
      type: 'object',
      properties: {
        category: {
          type: 'string',
          enum: [
            'all',
            'features',
            'pricing',
            'benefits',
            'support',
            'faq',
            'subscription',
          ],
          description: 'Category of information requested',
        },
      },
    },
  },
  {
    name: 'get_market_update',
    description:
      'Get a comprehensive update of the Indian stock market that includes trending NSE stocks and current market news.',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top stocks to fetch (default is 5).',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter stocks with price under this value (in INR).',
        },
      },
    },
  },
  {
    name: 'get_crypto_market_update',
    description:
      'Get a comprehensive update of the cryptocurrency market that includes trending cryptocurrencies and current crypto market news.',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top cryptocurrencies to fetch (default is 5).',
        },
        currency: {
          type: 'string',
          enum: ['USD', 'INR'],
          description:
            'Currency for the price. Default is USD. For INR conversion, use "INR".',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter cryptocurrencies with current price under this value (in the specified currency).',
        },
      },
    },
  },
];

/**
 * Helper: Fetch realtime data for a ticker.
 */
async function fetchRealtimeData(ticker) {
  try {
    const quote = await yahooFinance.quote(ticker);
    if (!quote) return null;
    const now = new Date().toISOString();
    return { dates: [now], prices: [quote.regularMarketPrice] };
  } catch (error) {
    console.error(`Error fetching realtime data for ${ticker}:`, error);
    return null;
  }
}

/**
 * Helper: Fetch historical data for a ticker.
 */
async function fetchHistoricalData(ticker, period1, period2, interval = '1d') {
  try {
    const historical = await yahooFinance.historical(ticker, { period1, period2, interval });
    return historical.map(item => ({
      date: item.date,
      price: item.close,
    }));
  } catch (error) {
    console.error(`Error fetching historical data for ${ticker}:`, error);
    return [];
  }
}

/**
 * Helper: Fetch detailed info for a ticker.
 */
async function fetchDetailedInfo(ticker) {
  try {
    const detailedInfo = await yahooFinance.quoteSummary(ticker, {
      modules: ['summaryDetail', 'summaryProfile', 'assetProfile']
    });
    return detailedInfo;
  } catch (error) {
    console.error(`Error fetching detailed info for ${ticker}:`, error);
    return null;
  }
}

/**
 * Helper: Fetch recent news for a ticker.
 */
async function fetchNews(ticker) {
  try {
    const searchResult = await yahooFinance.search(`${ticker} news`, { lang: 'en-IN', region: 'IN' });
    let news = searchResult.news || [];
    if (!news.length) {
      console.warn(`No news found for ${ticker}, fetching general market news.`);
      news = await fetchMarketNews();
    }
    return news;
  } catch (error) {
    console.error(`Error fetching news for ${ticker}:`, error);
    return [];
  }
}

/**
 * New Helper: Fetch general market news.
 */
async function fetchMarketNews() {
  try {
    const searchResult = await yahooFinance.search("Indian stock market", { lang: 'en-IN', region: 'IN' });
    return searchResult.news || [];
  } catch (error) {
    console.error("Error fetching market news:", error);
    return [];
  }
}

/**
 * New Helper: Fetch crypto market news.
 */
async function fetchCryptoMarketNews() {
  try {
    const searchResult = await yahooFinance.search("cryptocurrency market news", { lang: 'en-IN', region: 'IN' });
    return searchResult.news || [];
  } catch (error) {
    console.error("Error fetching crypto market news:", error);
    return [];
  }
}

/**
 * Fetch real-time stock data for Indian stocks.
 */
async function getStockPrice(symbols, underPrice) {
  const results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

  for (let symbol of symbols) {
    try {
      let querySymbol = symbol;
      if (!symbol.includes('.') && /^[A-Z]+$/.test(symbol)) {
        querySymbol = `${symbol}.NS`;
      }
      const quote = await yahooFinance.quote(querySymbol);
      const rtData = await fetchRealtimeData(querySymbol);
      if (!rtData) {
        results.push({ symbol, error: 'No real-time data available' });
        continue;
      }
      const history = await fetchHistoricalData(querySymbol, past7Days, now, '1d');
      const detailedInfo = await fetchDetailedInfo(querySymbol);
      const news = await fetchNews(querySymbol);

      results.push({
        symbol: querySymbol,
        name: quote.longName || symbol,
        dates: rtData.dates,
        prices: rtData.prices,
        history,
        change: quote.regularMarketChange,
        changePercentage: quote.regularMarketChangePercent,
        marketCap: quote.marketCap,
        detailedInfo,
        news
      });
    } catch (error) {
      console.error(`Error fetching stock price for ${symbol}:`, error);
      results.push({ symbol, error: 'Unable to fetch data' });
    }
  }
  if (underPrice !== undefined) {
    return results.filter((r) => r.prices[0] < underPrice);
  }
  return results;
}

/**
 * Fetch trending (top) Indian stocks in real time.
 */
async function getTopStocks(limit = 5, underPrice) {
  let results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

  try {
    const cookieResponse = await axios.get('https://www.nseindia.com', {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
        'Accept-Language': 'en-US,en;q=0.9'
      }
    });
    const cookies = cookieResponse.headers['set-cookie'];
    const cookieHeader = cookies ? cookies.join('; ') : '';

    const nseResponse = await axios.get(
      'https://www.nseindia.com/api/live-analysis-variations?index=gainers',
      {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
          'Accept': 'application/json',
          'Accept-Language': 'en-US,en;q=0.9',
          'Referer': 'https://www.nseindia.com/',
          'Cookie': cookieHeader,
        },
      }
    );
    const trendingData = nseResponse.data?.NIFTY?.data;
    if (!trendingData || trendingData.length === 0) {
      throw new Error('No trending data available from NSE API');
    }
    const symbols = trendingData
      .map((item) => item.symbol)
      .slice(0, limit)
      .map((sym) => (sym.includes('.') ? sym : sym + '.NS'));
    for (const symbol of symbols) {
      try {
        const quote = await yahooFinance.quote(symbol);
        const rtData = await fetchRealtimeData(symbol);
        if (!rtData) continue;
        const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
        const detailedInfo = await fetchDetailedInfo(symbol);
        const news = await fetchNews(symbol);
        results.push({
          symbol,
          name: quote.longName || symbol,
          dates: rtData.dates,
          prices: rtData.prices,
          history,
          change: quote.regularMarketChange,
          changePercentage: quote.regularMarketChangePercent,
          marketCap: quote.marketCap,
          detailedInfo,
          news
        });
      } catch (err) {
        console.error(`Error fetching realtime data for ${symbol}:`, err);
      }
    }
  } catch (error) {
    console.error('Error fetching top stocks from NSE:', error);
    return { error: 'Unable to fetch trending Indian stocks from NSE.' };
  }
  if (underPrice !== undefined) {
    results = results.filter((r) => r.prices[0] < underPrice);
  }
  return results;
}

/**
 * Fetch real-time cryptocurrency data.
 */
async function getCryptoPrice(symbols, currency = 'USD', underPrice) {
  let conversionRate = 1;
  if (currency === 'INR') {
    try {
      const rateQuote = await yahooFinance.quote('USDINR=X');
      conversionRate = rateQuote.regularMarketPrice || 1;
    } catch (error) {
      console.error('Error fetching conversion rate:', error);
    }
  }
  const results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  for (let symbol of symbols) {
    try {
      if (!symbol.includes('-')) {
        symbol = `${symbol}-USD`;
      }
      const quote = await yahooFinance.quote(symbol);
      const rtData = await fetchRealtimeData(symbol);
      if (!rtData) {
        results.push({ symbol, error: 'No real-time data available' });
        continue;
      }
      let price = rtData.prices[0];
      if (currency === 'INR') {
        price = price * conversionRate;
      }
      const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
      let detailedInfo = null;
      let news = [];
      try {
        detailedInfo = await fetchDetailedInfo(symbol);
        news = await fetchNews(symbol);
      } catch (err) {
        console.error(`Error fetching detailed info or news for ${symbol}:`, err);
      }
      results.push({
        symbol,
        name: quote.shortName || symbol,
        dates: rtData.dates,
        prices: [price],
        history,
        change: quote.regularMarketChange,
        changePercentage: quote.regularMarketChangePercent,
        marketCap: quote.marketCap,
        detailedInfo,
        news,
      });
    } catch (error) {
      console.error(`Error fetching crypto price for ${symbol}:`, error);
      results.push({ symbol, error: 'Unable to fetch data' });
    }
  }
  if (underPrice !== undefined) {
    const filtered = results.filter((r) => r.prices[0] < underPrice);
    return filtered.length > 0 ? filtered : [{ message: `No cryptocurrencies found with a price under ${underPrice}.` }];
  }
  return results;
}

/**
 * Fetch trending (top) cryptocurrencies in real time.
 */
async function getTopCryptos(limit = 5, currency = 'USD', underPrice) {
  let conversionRate = 1;
  if (currency === 'INR') {
    try {
      const rateQuote = await yahooFinance.quote('USDINR=X');
      conversionRate = rateQuote.regularMarketPrice || 1;
    } catch (error) {
      console.error('Error fetching conversion rate:', error);
    }
  }
  try {
    const response = await fetch(
      `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${limit}&page=1`
    );
    const coins = await response.json();
    if (!coins || !coins.length) {
      throw new Error('Failed to fetch top cryptocurrencies');
    }
    let results = [];
    const now = new Date();
    const past7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    for (const coin of coins) {
      const symbol = `${coin.symbol.toUpperCase()}-USD`;
      try {
        const quote = await yahooFinance.quote(symbol);
        const rtData = await fetchRealtimeData(symbol);
        if (!rtData) continue;
        let price = rtData.prices[0];
        if (currency === 'INR') {
          price = price * conversionRate;
        }
        const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
        results.push({
          symbol,
          name: quote.shortName || coin.name,
          dates: rtData.dates,
          prices: [price],
          history,
          change: quote.regularMarketChange,
          changePercentage: quote.regularMarketChangePercent,
          marketCap: quote.marketCap,
        });
      } catch (err) {
        console.error(`Error processing ${symbol}:`, err);
      }
    }
    if (underPrice !== undefined) {
      results = results.filter((r) => r.prices[0] < underPrice);
      return results.length > 0 ? results : [{ message: `No cryptocurrencies found with a price under ${underPrice}.` }];
    }
    return results;
  } catch (error) {
    console.error('Error fetching top cryptos:', error);
    return { error: 'Unable to fetch top cryptos' };
  }
}

/**
 * New Function: Fetch crypto market update.
 */
async function getCryptoMarketUpdate(limit = 2, currency = 'USD', underPrice) {
  const topCryptos = await getTopCryptos(limit, currency, underPrice);
  const cryptoNews = await fetchCryptoMarketNews();
  return {
    topCryptos,
    newsHighlights: cryptoNews.slice(0, 5)
  };
}

/**
 * New Function: Fetch market update.
 */
async function getMarketUpdate(limit = 2, underPrice) {
  const topStocks = await getTopStocks(limit, underPrice);
  const marketNews = await fetchMarketNews();
  return {
    topStocks,
    newsHighlights: marketNews.slice(0, 5)
  };
}

/**
 * Fetch company information from MongoDB Atlas.
 */
async function getCompanyInfo(args) {
  let category = args?.category || 'all';
  if (category === 'subscription') {
    category = 'pricing';
  }
  const companyDoc = await CompanyInfo.findOne({ name: 'Profit Flow' }).lean();
  if (!companyDoc) {
    throw new Error('Company information not found in the database.');
  }
  return category === 'all' ? companyDoc : { [category]: companyDoc[category] };
}

export async function POST(request) {
  try {
    const { messages } = await request.json();

    const userId = 'static-user-123'; // Replace with dynamic user ID in real app

    // Fetch user's previous reports
    const userLog = await UserChatLog.findOne({ userId });
    const reports = [];
    if (userLog) {
      userLog.messages.forEach(msg => {
        if (msg.actions?.report) {
          reports.push(msg.actions.reportMessage);
        }
      });
    }

    // Call OpenAI to get the initial assistant response.
    const initialResponse = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content:
            'You are a highly specialized financial analyst assistant focused exclusively on Indian stocks and crypto analysis. Provide responses in structured markdown format with clear bullet points, proper spacing between topics, and dynamic chart headings based on the query. Respond in a professional tone and include relevant suggestions when applicable. If a user asks about stocks outside of India, still provide Indian stock data only.',
        },
        ...messages,
      ],
      functions,
      function_call: 'auto',
    });
    const message = initialResponse.choices[0].message;

    // If OpenAI requested a function call, process that.
    if (message.function_call) {
      const functionName = message.function_call.name;
      const args = JSON.parse(message.function_call.arguments || '{}');
      let functionResponse;

      // Dispatch to the appropriate helper function.
      switch (functionName) {
        case 'get_stock_price':
          functionResponse = await getStockPrice(args.symbols, args.underPrice);
          break;
        case 'get_top_stocks':
          functionResponse = await getTopStocks(args.limit || 2, args.underPrice);
          break;
        case 'get_crypto_price':
          functionResponse = await getCryptoPrice(args.symbols, args.currency || 'USD', args.underPrice);
          break;
        case 'get_top_cryptos':
          functionResponse = await getTopCryptos(args.limit || 2, args.currency || 'USD', args.underPrice);
          break;
        case 'get_company_info':
          functionResponse = await getCompanyInfo(args);
          break;
        case 'get_market_update':
          functionResponse = await getMarketUpdate(args.limit || 2, args.underPrice);
          break;
        case 'get_crypto_market_update':
          functionResponse = await getCryptoMarketUpdate(args.limit || 2, args.currency || 'USD', args.underPrice);
          break;
        default:
          functionResponse = { error: 'Function not supported' };
      }

      // Generate the final assistant response.
      let finalResponse;
      if (functionName === 'get_company_info') {
        finalResponse = await openai.chat.completions.create({
          model: 'gpt-4o',
          messages: [
            ...messages,
            {
              role: 'system',
              content:
                'You are a friendly advisor providing company information. Keep your response clear, concise, and conversational. Limit your answer to under three paragraphs and include any offers naturally.',
            },
            {
              role: 'user',
              content: `Company Data:\n${JSON.stringify(functionResponse, null, 2)}`,
            },
          ],
          temperature: 0.7,
          max_tokens: 500,
        });
      } else {
        const responseTemplate = `Please generate a creative and professional financial update using the data provided below.
Data:
${JSON.stringify(functionResponse, null, 2)}

Ensure your response is engaging, well-structured, and adapts to the query context without using tables.`;
        finalResponse = await openai.chat.completions.create({
          model: 'gpt-4o',
          messages: [
            ...messages,
            {
              role: 'system',
              content:
                'You are a highly specialized financial analyst assistant focused exclusively on Indian stocks and crypto analysis. Provide responses in structured markdown format with clear bullet points, proper spacing between topics, and dynamic chart headings based on the query. Respond in a professional tone and include relevant suggestions when applicable. If a user asks about stocks outside of India, still provide Indian stock data only.' +
                (reports.length > 0
                  ? `\n\nUser feedback to consider: ${reports.slice(-3).join('. ')}. Address these concerns appropriately.`
                  : '') +
                '\n\nBased on the provided input data, generate an in-depth market analysis report that dynamically identifies all significant metrics. For each metric (e.g., Industry, Sector, Current Price, Market Capitalization, Dividend Rate, etc.), include:\n' +
                '- A detailed explanation of what the metric represents, why it is important, and its implications for investors.\n' +
                '- Additional context, such as trend analysis, comparisons, or any potential risks.\n\n' +
                'Ensure that your response is not just a list of data points but includes clear, explanatory sentences after each bullet point. Use markdown headings (like "## Company Profile" and "## Key Financial Metrics") and bullet points to organize the information.'
            },
            {
              role: 'user',
              content: responseTemplate,
            },
          ],                    
          temperature: 0.6,
          max_tokens: 1000,
        });
      }

      return NextResponse.json({
        ...finalResponse.choices[0].message,
        rawData: functionResponse,
        functionName: message.function_call.name,
      });
    } else {
      return NextResponse.json({
        role: 'assistant',
        content:
          message.content || "I'm here to help! Could you please clarify your request?",
      });
    }
  } catch (error) {
    console.error('API Error:', error);
    return NextResponse.json(
      {
        error: 'Financial data currently unavailable. Please try again later.',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined,
      },
      { status: 500 }
    );
  }
}

















// src/app/api/chat/route.js

import { NextResponse } from 'next/server';
import OpenAI from 'openai';
import mongoose from 'mongoose';
import CompanyInfo from '@/src/models/CompanyInfo';
import dotenv from 'dotenv';
import yahooFinance from 'yahoo-finance2';
import UserChatLog from '@/src/models/UserChatLog';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs';
import { NSELive, NSEArchive } from 'nse-api-package'; // New: Import NSELive and NSEArchive

dotenv.config({ path: '.env.local' });

const MONGODB_URI = process.env.MONGODB_URI;

// Reuse MongoDB connection in a serverless environment
if (!mongoose.connection.readyState) {
  mongoose
    .connect(MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    })
    .then(() => console.log('Connected to MongoDB Atlas'))
    .catch((err) => console.error('MongoDB connection error:', err));
}

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Initialize NSELive instance for realtime market status and additional endpoints
const nseLive = new NSELive();

const functions = [
  {
    name: 'get_stock_price',
    description:
      'Get real-time stock price (current quote), historical price data, and basic information for one or more stock symbols. This function always returns data for Indian stocks only.',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description: 'Array of stock symbols like ["RELIANCE", "TCS"] for Reliance and TCS.',
        },
        underPrice: {
          type: 'number',
          description: 'Optional: filter stocks with current price under this value (in INR).',
        },
      },
      required: ['symbols'],
    },
  },
  {
    name: 'get_crypto_price',
    description:
      'Get real-time cryptocurrency price (current quote), historical price data, and basic information for one or more crypto symbols. Optionally, specify the currency ("USD" or "INR") and a maximum price (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description:
            'Array of cryptocurrency symbols like ["BTC", "ETH"] for Bitcoin and Ethereum.',
        },
        currency: {
          type: 'string',
          enum: ['USD', 'INR'],
          description: 'Currency for the price. Default is USD. For INR conversion, use "INR".',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter cryptos with current price under this value (in the specified currency).',
        },
      },
      required: ['symbols'],
    },
  },
  {
    name: 'get_top_stocks',
    description:
      'Get the trending Indian stocks in real time using NSE data. Optionally, specify a price filter (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top stocks to fetch (default is 5).',
        },
        underPrice: {
          type: 'number',
          description: 'Optional: filter stocks with price under this value (in INR).',
        },
      },
    },
  },
  {
    name: 'get_top_cryptos',
    description:
      'Get the trending cryptocurrencies in real time. Optionally, specify the currency ("USD" or "INR") and a price filter (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top cryptos to fetch (default is 5).',
        },
        currency: {
          type: 'string',
          enum: ['USD', 'INR'],
          description: 'Currency for the price. Default is USD. For INR conversion, use "INR".',
        },
        underPrice: {
          type: 'number',
          description: 'Optional: filter cryptos with current price under this value (in the specified currency).',
        },
      },
    },
  },
  {
    name: 'get_company_info',
    description: 'Get information about Profit Flow company and services',
    parameters: {
      type: 'object',
      properties: {
        category: {
          type: 'string',
          enum: ['all', 'features', 'pricing', 'benefits', 'support', 'faq', 'subscription'],
          description: 'Category of information requested',
        },
      },
    },
  },
  {
    name: 'get_market_status',
    description: 'Get realtime Indian market status using NSELive data.',
    parameters: {
      type: 'object',
      properties: {}
    }
  },
  // New functions from NSELive API:
  {
    name: 'get_trade_info',
    description: 'Get detailed trade information for a specific equity using NSELive.',
    parameters: {
      type: 'object',
      properties: {
        symbol: {
          type: 'string',
          description: 'Stock symbol for which to fetch trade information.',
        },
      },
      required: ['symbol'],
    },
  },
  {
    name: 'get_stock_quote_fno',
    description: 'Fetch live F&O data for a specific equity using NSELive.',
    parameters: {
      type: 'object',
      properties: {
        symbol: {
          type: 'string',
          description: 'Stock symbol for which to fetch F&O data.',
        },
      },
      required: ['symbol'],
    },
  },
  {
    name: 'get_chart_data',
    description: 'Fetch chart data for a given symbol using NSELive.',
    parameters: {
      type: 'object',
      properties: {
        symbol: {
          type: 'string',
          description: 'Stock or index symbol for chart data.',
        },
        includeAdditionalData: {
          type: 'boolean',
          description: 'Optional flag to include additional chart details.',
        },
      },
      required: ['symbol'],
    },
  },
  {
    name: 'get_market_turnover',
    description: 'Fetch market turnover data for a given symbol using NSELive.',
    parameters: {
      type: 'object',
      properties: {
        symbol: {
          type: 'string',
          description: 'Stock symbol for which to fetch market turnover data.',
        },
      },
      required: ['symbol'],
    },
  },
  {
    name: 'get_equity_derivative_turnover',
    description: 'Fetch equity derivative turnover data for a given symbol using NSELive.',
    parameters: {
      type: 'object',
      properties: {
        symbol: {
          type: 'string',
          description: 'Stock symbol for which to fetch equity derivative turnover data.',
        },
      },
      required: ['symbol'],
    },
  },
  {
    name: 'get_all_indices',
    description: 'Fetch data of all indices using NSELive.',
    parameters: {
      type: 'object',
      properties: {}
    },
  },
  {
    name: 'get_live_index',
    description: 'Fetch realtime index data for a given symbol using NSELive.',
    parameters: {
      type: 'object',
      properties: {
        symbol: {
          type: 'string',
          description: 'Index symbol for which to fetch realtime data.',
        },
      },
      required: ['symbol'],
    },
  },
  {
    name: 'get_index_option_chain',
    description: 'Fetch the index option chain for a given symbol using NSELive.',
    parameters: {
      type: 'object',
      properties: {
        symbol: {
          type: 'string',
          description: 'Index symbol for which to fetch option chain data.',
        },
      },
      required: ['symbol'],
    },
  },
];


function calculateSMA(data, windowSize) {
  const sma = [];
  for (let i = 0; i < data.length; i++) {
    if (i < windowSize - 1) {
      sma.push(null);
    } else {
      const windowSlice = data.slice(i - windowSize + 1, i + 1);
      const sum = windowSlice.reduce((acc, val) => acc + val, 0);
      sma.push(sum / windowSize);
    }
  }
  return sma;
}

/**
 * Helper: Fetch realtime data for a ticker.
 */
async function fetchRealtimeData(ticker) {
  try {
    const quote = await yahooFinance.quote(ticker);
    if (!quote) return null;
    const now = new Date().toISOString();
    return { dates: [now], prices: [quote.regularMarketPrice] };
  } catch (error) {
    console.error(`Error fetching realtime data for ${ticker}:`, error);
    return null;
  }
}

/**
 * Helper: Fetch historical data for a ticker.
 */
async function fetchHistoricalData(ticker, period1, period2, interval = '1d') {
  try {
    const historical = await yahooFinance.historical(ticker, { period1, period2, interval });
    return historical.map(item => ({
      date: item.date,
      price: item.close,
      volume: item.volume, // Add volume data
    }));
  } catch (error) {
    console.error(`Error fetching historical data for ${ticker}:`, error);
    return [];
  }
}

/**
 * Helper: Fetch detailed info for a ticker.
 */
async function fetchDetailedInfo(ticker) {
  try {
    const detailedInfo = await yahooFinance.quoteSummary(ticker, {
      modules: ['summaryDetail', 'summaryProfile', 'assetProfile']
    });
    return detailedInfo;
  } catch (error) {
    console.error(`Error fetching detailed info for ${ticker}:`, error);
    return null;
  }
}

/**
 * Helper: Fetch recent news for a ticker.
 * (Retained for stock and crypto functions as needed)
 */
async function fetchNews(ticker) {
  try {
    const searchResult = await yahooFinance.search(`${ticker} news`, { lang: 'en-IN', region: 'IN' });
    let news = searchResult.news || [];
    if (!news.length) {
      console.warn(`No news found for ${ticker}.`);
    }
    return news;
  } catch (error) {
    console.error(`Error fetching news for ${ticker}:`, error);
    return [];
  }
}

/**
 * Fetch real-time stock data for Indian stocks.
 */
async function getStockPrice(symbols, underPrice) {
  const results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000);

  for (let symbol of symbols) {
    try {
      let querySymbol = symbol;
      if (!symbol.includes('.') && /^[A-Z]+$/.test(symbol)) {
        querySymbol = `${symbol}.NS`;
      }
      const quote = await yahooFinance.quote(querySymbol);
      const rtData = await fetchRealtimeData(querySymbol);
      if (!rtData) {
        results.push({ symbol, error: 'No real-time data available' });
        continue;
      }
      const history = await fetchHistoricalData(querySymbol, past7Days, now, '1d');
      const detailedInfo = await fetchDetailedInfo(querySymbol);
      const news = await fetchNews(querySymbol);

      results.push({
        symbol: querySymbol,
        name: quote.longName || symbol,
        dates: rtData.dates,
        prices: rtData.prices,
        history,
        change: quote.regularMarketChange,
        changePercentage: quote.regularMarketChangePercent,
        marketCap: quote.marketCap,
        detailedInfo,
        news
      });
    } catch (error) {
      console.error(`Error fetching stock price for ${symbol}:`, error);
      results.push({ symbol, error: 'Unable to fetch data' });
    }
  }
  if (underPrice !== undefined) {
    return results.filter((r) => r.prices[0] < underPrice);
  }
  return results;
}

// Fetch trending (top) stocks.
async function getTopStocks(limit = 5, underPrice) {
  let results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000);

  try {
    const cookieResponse = await axios.get('https://www.nseindia.com', {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
        'Accept-Language': 'en-US,en;q=0.9'
      }
    });
    const cookies = cookieResponse.headers['set-cookie'];
    const cookieHeader = cookies ? cookies.join('; ') : '';

    const nseResponse = await axios.get(
      'https://www.nseindia.com/api/live-analysis-variations?index=gainers',
      {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
          'Accept': 'application/json',
          'Accept-Language': 'en-US,en;q=0.9',
          'Referer': 'https://www.nseindia.com/',
          'Cookie': cookieHeader,
        },
      }
    );
    const trendingData = nseResponse.data?.NIFTY?.data;
    if (!trendingData || trendingData.length === 0) {
      throw new Error('No trending data available from NSE API');
    }
    const symbols = trendingData
      .map((item) => item.symbol)
      .slice(0, limit)
      .map((sym) => (sym.includes('.') ? sym : sym + '.NS'));
    for (const symbol of symbols) {
      try {
        const quote = await yahooFinance.quote(symbol);
        const rtData = await fetchRealtimeData(symbol);
        if (!rtData) continue;
        const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
        const detailedInfo = await fetchDetailedInfo(symbol);
        const news = await fetchNews(symbol);
        results.push({
          symbol,
          name: quote.longName || symbol,
          dates: rtData.dates,
          prices: rtData.prices,
          history,
          change: quote.regularMarketChange,
          changePercentage: quote.regularMarketChangePercent,
          marketCap: quote.marketCap,
          detailedInfo,
          news
        });
      } catch (err) {
        console.error(`Error fetching realtime data for ${symbol}:`, err);
      }
    }
  } catch (error) {
    console.error('Error fetching top stocks from NSE:', error);
    return { error: 'Unable to fetch trending Indian stocks from NSE.' };
  }
  if (underPrice !== undefined) {
    results = results.filter((r) => r.prices[0] < underPrice);
  }
  return results;
}

// Fetch real-time crypto data.
async function getCryptoPrice(symbols, currency = 'USD', underPrice) {
  let conversionRate = 1;
  if (currency === 'INR') {
    try {
      const rateQuote = await yahooFinance.quote('USDINR=X');
      conversionRate = rateQuote.regularMarketPrice || 1;
    } catch (error) {
      console.error('Error fetching conversion rate:', error);
    }
  }
  const results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000);
  for (let symbol of symbols) {
    try {
      if (!symbol.includes('-')) {
        symbol = `${symbol}-USD`;
      }
      const quote = await yahooFinance.quote(symbol);
      const rtData = await fetchRealtimeData(symbol);
      if (!rtData) {
        results.push({ symbol, error: 'No real-time data available' });
        continue;
      }
      let price = rtData.prices[0];
      if (currency === 'INR') {
        price = price * conversionRate;
      }
      const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
      let detailedInfo = null;
      let news = [];
      try {
        detailedInfo = await fetchDetailedInfo(symbol);
        news = await fetchNews(symbol);
      } catch (err) {
        console.error(`Error fetching detailed info or news for ${symbol}:`, err);
      }
      results.push({
        symbol,
        name: quote.shortName || symbol,
        dates: rtData.dates,
        prices: [price],
        history,
        change: quote.regularMarketChange,
        changePercentage: quote.regularMarketChangePercent,
        marketCap: quote.marketCap,
        detailedInfo,
        news
      });
    } catch (error) {
      console.error(`Error fetching crypto price for ${symbol}:`, error);
      results.push({ symbol, error: 'Unable to fetch data' });
    }
  }
  if (underPrice !== undefined) {
    const filtered = results.filter((r) => r.prices[0] < underPrice);
    return filtered.length > 0 ? filtered : [{ message: `No cryptocurrencies found with a price under ${underPrice}.` }];
  }
  return results;
}

async function getTopCryptos(limit = 5, currency = 'USD', underPrice) {
  let conversionRate = 1;
  if (currency === 'INR') {
    try {
      const rateQuote = await yahooFinance.quote('USDINR=X');
      conversionRate = rateQuote.regularMarketPrice || 1;
    } catch (error) {
      console.error('Error fetching conversion rate:', error);
    }
  }
  try {
    const response = await fetch(
      `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${limit}&page=1`
    );
    const coins = await response.json();
    if (!coins || !coins.length) {
      throw new Error('Failed to fetch top cryptocurrencies');
    }
    let results = [];
    const now = new Date();
    const past7Days = new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000);
    for (const coin of coins) {
      const symbol = `${coin.symbol.toUpperCase()}-USD`;
      try {
        const quote = await yahooFinance.quote(symbol);
        const rtData = await fetchRealtimeData(symbol);
        if (!rtData) continue;
        let price = rtData.prices[0];
        if (currency === 'INR') {
          price = price * conversionRate;
        }
        const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
        results.push({
          symbol,
          name: quote.shortName || coin.name,
          dates: rtData.dates,
          prices: [price],
          history,
          change: quote.regularMarketChange,
          changePercentage: quote.regularMarketChangePercent,
          marketCap: quote.marketCap,
        });
      } catch (err) {
        console.error(`Error processing ${symbol}:`, err);
      }
    }
    if (underPrice !== undefined) {
      results = results.filter((r) => r.prices[0] < underPrice);
      return results.length > 0 ? results : [{ message: `No cryptocurrencies found with a price under ${underPrice}.` }];
    }
    return results;
  } catch (error) {
    console.error('Error fetching top cryptos:', error);
    return { error: 'Unable to fetch top cryptos' };
  }
}

/**
 * New Function: Fetch realtime market status using NSELive.
 */
async function getMarketStatus() {
  try {
    const status = await nseLive.marketStatus();
    return status;
  } catch (error) {
    console.error("Error fetching realtime market status:", error);
    return { error: "Unable to fetch realtime market status" };
  }
}

/**
 * New Function: Fetch trade information for a specific equity using NSELive.
 */
async function getTradeInfo({ symbol }) {
  try {
    const info = await nseLive.tradeInfo(symbol);
    return info;
  } catch (error) {
    console.error(`Error fetching trade info for ${symbol}:`, error);
    return { error: "Unable to fetch trade info" };
  }
}

/**
 * New Function: Fetch live F&O data for a specific equity using NSELive.
 */
async function getStockQuoteFNO({ symbol, optionsRequiredMonth }) {
  try {
    // Fetch raw data from the NSELive API
    const rawData = await nseLive.stockQuoteFNO(symbol);

    // The underlying asset's current value (common for both futures and options)
    const underlyingValue = rawData.underlyingValue;

    // Initialize arrays to hold processed futures and options data
    const futuresData = [];
    const optionsData = [];

    // Process each contract in the raw data
    if (Array.isArray(rawData.stocks)) {
      rawData.stocks.forEach((stock) => {
        const meta = stock.metadata;
        const orderBook = stock.marketDeptOrderBook;
        if (!meta || !orderBook) return; // skip if essential data is missing

        // Prepare a base object with fields common to both types:
        const commonFields = {
          lastPrice: meta.lastPrice,
          change: meta.change,
          pChange: meta.pChange,
          contractsTraded: meta.numberOfContractsTraded,
          totalTurnover: meta.totalTurnover,
          openInterest: orderBook.tradeInfo ? orderBook.tradeInfo.openInterest : undefined,
          changeInOpenInterest: orderBook.tradeInfo ? orderBook.tradeInfo.changeinOpenInterest : undefined,
          pChangeInOpenInterest: orderBook.tradeInfo ? orderBook.tradeInfo.pchangeinOpenInterest : undefined,
          orderBook: {
            bid: orderBook.bid,
            ask: orderBook.ask,
          }
        };

        // Process Futures: Critical fields include underlying value, price, volume, OI, order book, and volatility measures.
        if (meta.instrumentType === 'Stock Futures') {
          futuresData.push({
            ...commonFields,
            volatility: {
              daily: orderBook.otherInfo ? orderBook.otherInfo.dailyvolatility : undefined,
              annualised: orderBook.otherInfo ? orderBook.otherInfo.annualisedVolatility : undefined,
              // For futures the implied volatility might be absent or zero
              implied: orderBook.otherInfo ? orderBook.otherInfo.impliedVolatility : undefined
            }
          });
        }
        // Process Options: Critical fields include contract details plus pricing, OI, order book, and implied volatility.
        else if (meta.instrumentType === 'Stock Options') {
          // If a required month is specified, filter by the expiry month.
          if (optionsRequiredMonth && meta.expiryDate) {
            // Assume expiryDate is in "DD-MMM-YYYY" format (e.g., "27-Feb-2025")
            const parts = meta.expiryDate.split('-');
            if (parts.length < 2) return;
            const monthStr = parts[1];
            if (monthStr.toLowerCase() !== optionsRequiredMonth.toLowerCase()) return;
          }
          optionsData.push({
            optionType: meta.optionType,         // "Call" or "Put"
            strikePrice: meta.strikePrice,
            expiryDate: meta.expiryDate,
            identifier: meta.identifier,
            ...commonFields,
            impliedVolatility: orderBook.otherInfo ? orderBook.otherInfo.impliedVolatility : undefined
          });
        }
      });
    }

    // Limit options data to the first three contracts (if more than three are returned)
    const limitedOptionsData = optionsData.slice(0, 3);

    // Optionally, log the processed data for record-keeping or debugging.
    const logEntry = [
      `Timestamp: ${new Date().toISOString()}`,
      `Symbol: ${symbol}`,
      `Underlying Value: ${underlyingValue}`,
      `Futures Data: ${JSON.stringify(futuresData, null, 2)}`,
      `Options Data (limited to 3): ${JSON.stringify(limitedOptionsData, null, 2)}`,
      '-------------------------\n'
    ].join('\n');

    fs.appendFile('fno_data.log', logEntry, (err) => {
      if (err) {
        console.error('Error writing F&O data to file:', err);
      }
    });

    // Return an object containing the underlying value, futures data, and options data.
    return {
      underlyingValue,
      futuresData,
      optionsData: limitedOptionsData,
      fut_timestamp: rawData.fut_timestamp,
      opt_timestamp: rawData.opt_timestamp,
      info: rawData.info
    };
  } catch (error) {
    console.error(`Error fetching critical F&O data for ${symbol}:`, error);
    return { error: "Unable to fetch F&O data" };
  }
}


/**
 * New Function: Fetch chart data for a given symbol using NSELive.
 */
async function getChartData({ symbol, includeAdditionalData }) {
  try {
    const data = await nseLive.chartData(symbol, includeAdditionalData);
    return data;
  } catch (error) {
    console.error(`Error fetching chart data for ${symbol}:`, error);
    return { error: "Unable to fetch chart data" };
  }
}

/**
 * New Function: Fetch market turnover data for a given symbol using NSELive.
 */
async function getMarketTurnover({ symbol }) {
  try {
    const data = await nseLive.marketTurnover(symbol);
    return data;
  } catch (error) {
    console.error(`Error fetching market turnover for ${symbol}:`, error);
    return { error: "Unable to fetch market turnover" };
  }
}

/**
 * New Function: Fetch equity derivative turnover data for a given symbol using NSELive.
 */
async function getEquityDerivativeTurnover({ symbol }) {
  try {
    const data = await nseLive.equityDerivativeTurnover(symbol);
    return data;
  } catch (error) {
    console.error(`Error fetching equity derivative turnover for ${symbol}:`, error);
    return { error: "Unable to fetch equity derivative turnover" };
  }
}

/**
 * New Function: Fetch data of all indices using NSELive.
 */
async function getAllIndices() {
  try {
    const data = await nseLive.allIndices();
    return data;
  } catch (error) {
    console.error("Error fetching all indices:", error);
    return { error: "Unable to fetch all indices" };
  }
}

/**
 * New Function: Fetch live index data for a given symbol using NSELive.
 */
async function getLiveIndex({ symbol }) {
  try {
    const data = await nseLive.liveIndex(symbol);
    return data;
  } catch (error) {
    console.error(`Error fetching live index for ${symbol}:`, error);
    return { error: "Unable to fetch live index" };
  }
}

/**
 * New Function: Fetch index option chain for a given symbol using NSELive.
 */
async function getIndexOptionChain({ symbol }) {
  try {
    const data = await nseLive.indexOptionChain(symbol);
    return data;
  } catch (error) {
    console.error(`Error fetching index option chain for ${symbol}:`, error);
    return { error: "Unable to fetch index option chain" };
  }
}

/**
 * Fetch company information from MongoDB Atlas.
 */
async function getCompanyInfo(args) {
  let category = args?.category || 'all';
  if (category === 'subscription') {
    category = 'pricing';
  }
  const companyDoc = await CompanyInfo.findOne({ name: 'Profit Flow' }).lean();
  if (!companyDoc) {
    throw new Error('Company information not found in the database.');
  }
  return category === 'all' ? companyDoc : { [category]: companyDoc[category] };
}

export async function POST(request) {
  try {
    const { messages } = await request.json();
    const userId = 'static-user-123'; // Replace with dynamic user ID in real app

    // Fetch user's previous reports
    const userLog = await UserChatLog.findOne({ userId });
    const reports = [];
    if (userLog) {
      userLog.messages.forEach(msg => {
        if (msg.actions?.report) {
          reports.push(msg.actions.reportMessage);
        }
      });
    }

    // Call OpenAI to get the initial assistant response.
    const initialResponse = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content:
            "You are a highly specialized financial analyst assistant focused exclusively on Indian stocks and crypto analysis. Provide responses in structured markdown format with clear bullet points, proper spacing between topics, and dynamic chart headings based on the query. Respond in a professional tone and include relevant suggestions when applicable.\n\n" +
            "STRICT RULES:\n" +
            "- Do not answer any off-topic questions that do not pertain directly to stock or crypto analysis. If a user submits an off-topic query, politely indicate that you can only assist with financial market analysis.\n" +
            "- Do not provide any details about the underlying code, API usage, or built-in systems. If asked technical questions about the implementation (e.g., which API is used for real-time stock prices), respond with a standard refusal message such as 'I'm sorry, but I cannot disclose details about my internal systems.'\n",
        },
        ...messages,
      ],
      functions,
      function_call: 'auto',
    });
    const message = initialResponse.choices[0].message;

    // If OpenAI requested a function call, process that.
    if (message.function_call) {
      const functionName = message.function_call.name;
      const args = JSON.parse(message.function_call.arguments || '{}');
      let functionResponse;

      // Dispatch to the appropriate helper function.
      switch (functionName) {
        case 'get_stock_price':
          functionResponse = await getStockPrice(args.symbols, args.underPrice);
          break;
        case 'get_top_stocks':
          functionResponse = await getTopStocks(args.limit || 2, args.underPrice);
          break;
        case 'get_crypto_price':
          functionResponse = await getCryptoPrice(args.symbols, args.currency || 'USD', args.underPrice);
          break;
        case 'get_top_cryptos':
          functionResponse = await getTopCryptos(args.limit || 2, args.currency || 'USD', args.underPrice);
          break;
        case 'get_company_info':
          functionResponse = await getCompanyInfo(args);
          break;
        case 'get_market_status':
          functionResponse = await getMarketStatus();
          break;
        // New cases for additional NSELive endpoints:
        case 'get_trade_info':
          functionResponse = await getTradeInfo(args);
          break;
        case 'get_stock_quote_fno':
          functionResponse = await getStockQuoteFNO(args);
          break;
        case 'get_chart_data':
          functionResponse = await getChartData(args);
          break;
        case 'get_market_turnover':
          functionResponse = await getMarketTurnover(args);
          break;
        case 'get_equity_derivative_turnover':
          functionResponse = await getEquityDerivativeTurnover(args);
          break;
        case 'get_all_indices':
          functionResponse = await getAllIndices();
          break;
        case 'get_live_index':
          functionResponse = await getLiveIndex(args);
          break;
        case 'get_index_option_chain':
          functionResponse = await getIndexOptionChain(args);
          break;
        default:
          functionResponse = { error: 'Function not supported' };
      }
      // Process chart data: compute a 15-day SMA for each asset
      if (functionResponse && Array.isArray(functionResponse) && functionResponse.length > 0) {
        if (functionResponse[0].history && functionResponse[0].history.length > 0) {
          const labels = functionResponse[0].history.map((item) =>
            new Date(item.date).toLocaleDateString()
          );
          const priceDatasets = [];
          functionResponse.forEach((asset, index) => {
            const priceData = asset.history.map((item) => item.price);
            const datasetColor = `hsl(${(index * 360) / functionResponse.length}, 70%, 50%)`;
            priceDatasets.push({
              label: asset.symbol || asset.name || `Asset ${index + 1}`,
              data: priceData,
              fill: false,
              borderColor: datasetColor,
              backgroundColor: datasetColor,
              tension: 0.1,
            });
            if (priceData.length > 0) {
              // Compute a 15-day SMA (cumulative average if fewer than 15 days)
              const sma15 = calculateSMA(priceData, 15);
              priceDatasets.push({
                label: `${asset.symbol || asset.name} 15-Day SMA`,
                data: sma15,
                fill: false,
                borderColor: "yellow",
                borderDash: [5, 5],
                tension: 0.1,
              });
            }
            const volumeData = asset.history.map((item) => item.volume);
            priceDatasets.push({
              label: `${asset.symbol || asset.name} Volume`,
              data: volumeData,
              type: 'bar',
              yAxisID: 'volume-y-axis',
              backgroundColor: 'rgba(75, 192, 192, 0.2)',
              borderColor: 'rgba(75, 192, 192, 1)',
              borderWidth: 1,
              order: 0, // Draw volume behind other datasets
            });
          });
          const chartData = { labels, datasets: priceDatasets };
          functionResponse.chartData = chartData;
          functionResponse.chartTitle = `${functionResponse
            .map((item) => item.symbol)
            .join(" & ")} Price History`;
        }
      }

      let finalResponse;
      if (functionName === "get_company_info") {
        finalResponse = await openai.chat.completions.create({
          model: "gpt-4o",
          messages: [
            ...messages,
            {
              role: "system",
              content:
                "You are a friendly advisor providing company information. Keep your response clear, concise, and conversational. Limit your answer to under three paragraphs and include any offers naturally.",
            },
            {
              role: "user",
              content: `Company Data:\n${JSON.stringify(functionResponse, null, 2)}`,
            },
          ],
          temperature: 0.7,
          max_tokens: 500,
        });
      } else {
        const responseTemplate = `Please generate a creative and professional financial update using the data provided below.
Data:
${JSON.stringify(functionResponse, null, 2)}

Ensure your response is engaging, well-structured, and adapts to the query context without using tables.`;
        finalResponse = await openai.chat.completions.create({
          model: "gpt-4o",
          messages: [
            ...messages,
            {
              role: "system",
              content:
                "You are a highly specialized financial analyst assistant focused exclusively on Indian stocks and crypto analysis. Provide responses in structured markdown format using clear headings and full sentences that form a cohesive narrative. Respond in a professional tone and include relevant suggestions when applicable.\n\n" +
                "STRICT RULES:\n" +
                "- Keep response under 100 words.\n" +
                "- Tailor your language based on the user's technical tone: If the user communicates in a non-technical way, provide clear and simple explanations; if the user uses technical language, adopt a more detailed explanation.\n" +
                "- Provide only the data that is directly relevant to the query. Avoid including excessive or extraneous information.\n" +
                "- Highlight essential data points, such as **current price**, in bold and present all related details in a clear and concise manner.\n" +
                "Based on the provided input data, generate an in-depth market analysis report that dynamically identifies all significant metrics. Include a detailed explanation of what each metric represents, why it is important, and its implications for investors, along with additional context such as trend analysis, comparisons, or potential risks.\n" +
                "Ensure your response goes beyond simply listing data points by including clear, explanatory sentences and a narrative that ties the data together. Use markdown headings (like '## Company Profile' and '## Key Financial Metrics') to organize the information. Add numbering with bullet points for heading and subheadings\n" +
                (reports.length > 0
                  ? `User feedback to consider: ${reports.slice(-3).join(". ")}. Address these concerns appropriately.\n\n`
                  : "")
            },
            {
              role: "user",
              content: responseTemplate,
            },
          ],
          temperature: 0.6,
          max_tokens: 1000,
        });
      }
      console.log(reports);
      return NextResponse.json({
        ...finalResponse.choices[0].message,
        rawData: functionResponse,
        functionName: message.function_call.name,
      });
    } else {
      return NextResponse.json({
        role: "assistant",
        content:
          message.content ||
          "I'm here to help! Could you please clarify your request?",
      });
    }
  } catch (error) {
    console.error("API Error:", error);
    return NextResponse.json(
      {
        error: "Financial data currently unavailable. Please try again later.",
        details:
          process.env.NODE_ENV === "development" ? error.message : undefined,
      },
      { status: 500 }
    );
  }
}








































// src/app/api/chat/route.js

import { NextResponse } from "next/server";
import OpenAI from "openai";
import mongoose from "mongoose";
import CompanyInfo from "@/models/CompanyInfo";
import dotenv from "dotenv";
import yahooFinance from "yahoo-finance2";
import UserChatLog from "@/models/UserChatLog";
import axios from "axios";
import fs from "fs";
import { NSELive, NSEArchive } from "nse-api-package"; // New: Import NSELive and NSEArchive
import { load } from 'cheerio';
const puppeteer = require('puppeteer');
import moment from 'moment';

dotenv.config({ path: '.env.local' });

const MONGODB_URI = process.env.MONGODB_URI;

// Reuse MongoDB connection in a serverless environment
if (!mongoose.connection.readyState) {
  mongoose
    .connect(MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    })
    .then(() => console.log('Connected to MongoDB Atlas'))
    .catch((err) => console.error('MongoDB connection error:', err));
}

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Initialize NSELive instance for realtime market status and additional endpoints
const nseLive = new NSELive();

const functions = [
  {
    name: 'get_stock_price',
    description:
      'Get real-time stock price (current quote), historical price data, and basic information for one or more stock symbols. This function always returns data for Indian stocks only.',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description: 'Array of stock symbols like ["RELIANCE", "TCS"] for Reliance and TCS.',
        },
        underPrice: {
          type: 'number',
          description: 'Optional: filter stocks with current price under this value (in INR).',
        },
      },
      required: ['symbols'],
    },
  },
  {
    name: 'get_crypto_price',
    description:
      'Get real-time cryptocurrency price (current quote), historical price data, and basic information for one or more crypto symbols. Optionally, specify the currency ("USD" or "INR") and a maximum price (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description:
            'Array of cryptocurrency symbols like ["BTC", "ETH"] for Bitcoin and Ethereum.',
        },
        currency: {
          type: 'string',
          enum: ['USD', 'INR'],
          description: 'Currency for the price. Default is USD. For INR conversion, use "INR".',
        },
        underPrice: {
          type: 'number',
          description:
            'Optional: filter cryptos with current price under this value (in the specified currency).',
        },
      },
      required: ['symbols'],
    },
  },
  {
    name: 'get_top_stocks',
    description:
      'Get the trending Indian stocks in real time using NSE data. Optionally, specify a price filter (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top stocks to fetch (default is 5).',
        },
        underPrice: {
          type: 'number',
          description: 'Optional: filter stocks with price under this value (in INR).',
        },
      },
    },
  },
  {
    name: 'get_top_cryptos',
    description:
      'Get the trending cryptocurrencies in real time. Optionally, specify the currency ("USD" or "INR") and a price filter (underPrice).',
    parameters: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Number of top cryptos to fetch (default is 5).',
        },
        currency: {
          type: 'string',
          enum: ['USD', 'INR'],
          description: 'Currency for the price. Default is USD. For INR conversion, use "INR".',
        },
        underPrice: {
          type: 'number',
          description: 'Optional: filter cryptos with current price under this value (in the specified currency).',
        },
      },
    },
  },
  {
    name: 'get_company_info',
    description: 'Get information about Profit Flow company and services',
    parameters: {
      type: 'object',
      properties: {
        category: {
          type: 'string',
          enum: ['all', 'features', 'pricing', 'benefits', 'support', 'faq', 'subscription'],
          description: 'Category of information requested',
        },
      },
    },
  },
  {
    name: 'get_market_status',
    description: 'Get realtime Indian market status using NSELive data.',
    parameters: {
      type: 'object',
      properties: {}
    }
  },
  // New functions from NSELive API:
  {
    name: 'get_trade_info',
    description: 'Get detailed trade information for a specific equity using NSELive.',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description: 'Array of stock symbols for which to fetch trade information.',
        },
      },
      required: ['symbol'],
    },
  },
  {
    name: 'get_stock_quote_fno',
    description: 'Fetch live F&O data for a specific equity using NSELive.',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description: 'Array of stock symbols for which to fetch F&O data.',
        },
      },
      required: ['symbol'],
    },
  },
  {
    name: 'get_chart_data',
    description: 'Fetch chart data for a given symbol using NSELive.',
    parameters: {
      type: 'object',
      properties: {
        symbol: {
          type: 'string',
          description: 'Stock or index symbol for chart data.',
        },
        includeAdditionalData: {
          type: 'boolean',
          description: 'Optional flag to include additional chart details.',
        },
      },
      required: ['symbol'],
    },
  },
  {
    name: 'calculate_stock_roi',
    description:
      'Calculate the ROI (Return on Investment) for a specific stock over a given period (1month, 3month, 6month, or 1year).',
    parameters: {
      type: 'object',
      properties: {
        symbol: {
          type: 'string',
          description: 'Stock symbol, e.g. "RELIANCE".',
        },
        period: {
          type: 'string',
          enum: ['1month', '3month', '6month', '1year'],
          description: 'Time period for ROI calculation.',
        },
      },
      required: ['symbol', 'period'],
    },
  },
  {
    name: 'get_highest_return_stock',
    description: 'Scrape the screener website to determine which stock has the highest return over specified period (1month, 3month, 6month, or 1year) and return its name and return percentage.',
    parameters: {
      type: 'object',
      properties: {
        period: {
          type: 'string',
          enum: ['1month', '3month', '6month', '1year'],
          description: 'Time period for ROI calculation.',
        },
      },
      required: ['period'],
    },
  },
  // {
  //   name: 'get_market_turnover',
  //   description: 'Fetch market turnover data for a given symbol using NSELive.',
  //   parameters: {
  //     type: 'object',
  //     properties: {
  //       symbol: {
  //         type: 'string',
  //         description: 'Stock symbol for which to fetch market turnover data.',
  //       },
  //     },
  //     required: ['symbol'],
  //   },
  // },
  // {
  //   name: 'get_equity_derivative_turnover',
  //   description: 'Fetch equity derivative turnover data for a given symbol using NSELive.',
  //   parameters: {
  //     type: 'object',
  //     properties: {
  //       symbol: {
  //         type: 'string',
  //         description: 'Stock symbol for which to fetch equity derivative turnover data.',
  //       },
  //     },
  //     required: ['symbol'],
  //   },
  // },
  {
    name: 'get_all_indices',
    description: 'Fetch data of all indices using NSELive.',
    parameters: {
      type: 'object',
      properties: {}
    },
  },
  {
    name: 'get_live_index',
    description: 'Fetch realtime index data for given symbols using pre-loaded indices data',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description: 'Array of index names/symbols to fetch (e.g. ["NIFTY 50", "NIFTY NEXT 50"])',
        },
      },
      required: ['symbols'],
    },
  },
  {
    name: 'get_gainers_and_losers',
    description: 'Fetch top gainers, top losers, or both from NSELive depending on the user query.',
    parameters: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'User query specifying what data to fetch (e.g. "top gainers", "top losers", or "gainers and losers").',
        },
      },
      required: ['query'],
    },
  },
  {
    name: 'get_volume_gainers',
    description: 'Fetch volume gainers data using NSELive.',
    parameters: {
      type: 'object',
      properties: {} // No parameters needed
    }
  },

  {
    name: 'should_purchase_stock',
    description:
      'Analyzes a given stock by comparing its current price to the historical average over a specified period, and provides a recommendation on whether to purchase the stock today.',
    parameters: {
      type: 'object',
      properties: {
        symbols: {
          type: 'array',
          items: { type: 'string' },
          description: 'Stock symbol (e.g. "RELIANCE").',
        },
        period: {
          type: 'string',
          description: 'Time period for historical analysis (e.g. "30days", "15days", "1month"). Defaults to "30days".',
        },
      },
      required: ['symbol'],
    },
  },
  {
    name: 'get_best_stocks_under_price',
    description: 'Get recommended stocks within a specified price range and/or under a certain market cap based on fundamental analysis criteria from Screener.in.',
    parameters: {
      type: 'object',
      properties: {
        minPrice: {
          type: 'number',
          description: 'Optional minimum price (in INR). If provided, returns stocks priced above this value.',
        },
        maxPrice: {
          type: 'number',
          description: 'Maximum price (in INR). Stocks must be priced below this value.',
        },
        maxMarketCap: {
          type: 'number',
          description: 'Optional maximum market cap in crore INR. If provided, filters stocks by market cap below this value.',
        }
      },
      required: ['maxPrice']
    }
  },
  {
    name: 'get_option_chain_data',
    description: 'Analyze option contracts (PUT/CALL) for NSE indices. Use this for evaluating strike prices, open interest, premiums, and volatility. Returns critical data for options trading decisions including moneyness, OI changes, and IV analysis.',
    parameters: {
      type: 'object',
      properties: {
        symbol: {
          type: 'string',
          enum: ['BANKNIFTY', 'NIFTY'],
          description: 'Index name - BANKNIFTY for banking sector, NIFTY for Nifty 50',
        },
        strikePrice: {
          type: 'number',
          description: 'Exact strike price being analyzed (e.g., 49000)',
        },
        optionType: {
          type: 'string',
          enum: ['PE', 'CE'],
          description: 'PE for Put Options, CE for Call Options',
        },
        expiryDate: {
          type: 'string',
          description: 'Optional expiry in DD-MMM-YYYY format',
        }
      },
      required: ['symbol', 'strikePrice', 'optionType'],
    },
  }
  // {
  //   name: 'get_index_option_chain',
  //   description: 'Fetch the index option chain for a given symbol using NSELive.',
  //   parameters: {
  //     type: 'object',
  //     properties: {
  //       symbol: {
  //         type: 'string',
  //         description: 'Index symbol for which to fetch option chain data.',
  //       },
  //     },
  //     required: [],
  //   },
  // },
];


function calculateSMA(data, windowSize) {
  const sma = [];
  for (let i = 0; i < data.length; i++) {
    if (i < windowSize - 1) {
      sma.push(null);
    } else {
      const windowSlice = data.slice(i - windowSize + 1, i + 1);
      const sum = windowSlice.reduce((acc, val) => acc + val, 0);
      sma.push(sum / windowSize);
    }
  }
  return sma;
}

/**
 * Helper: Fetch realtime data for a ticker.
 */
async function fetchRealtimeData(ticker) {
  try {
    const quote = await yahooFinance.quote(ticker);
    if (!quote) return null;
    const now = new Date().toISOString();
    return { dates: [now], prices: [quote.regularMarketPrice] };
  } catch (error) {
    console.error(`Error fetching realtime data for ${ticker}:`, error);
    return null;
  }
}

/**
 * Helper: Fetch historical data for a ticker.
 */
async function fetchHistoricalData(ticker, period1, period2, interval = '1d') {
  try {
    const historical = await yahooFinance.historical(ticker, { period1, period2, interval });
    return historical.map(item => ({
      date: item.date,
      price: item.close,
      volume: item.volume, // Add volume data
    }));
  } catch (error) {
    console.error(`Error fetching historical data for ${ticker}:`, error);
    return [];
  }
}

/**
 * Helper: Fetch detailed info for a ticker.
 */
async function fetchDetailedInfo(ticker) {
  try {
    const detailedInfo = await yahooFinance.quoteSummary(ticker, {
      modules: ['summaryDetail', 'summaryProfile', 'assetProfile']
    });
    return detailedInfo;
  } catch (error) {
    console.error(`Error fetching detailed info for ${ticker}:`, error);
    return null;
  }
}

/**
 * Helper: Fetch recent news for a ticker.
 * (Retained for stock and crypto functions as needed)
 */
async function fetchNews(ticker) {
  try {
    const searchResult = await yahooFinance.search(`${ticker} news`, { lang: 'en-IN', region: 'IN' });
    let news = searchResult.news || [];
    if (!news.length) {
      console.warn(`No news found for ${ticker}.`);
    }
    return news;
  } catch (error) {
    console.error(`Error fetching news for ${ticker}:`, error);
    return [];
  }
}

/**
 * Fetch real-time stock data for Indian stocks.
 */
async function getStockPrice(symbols, underPrice) {
  const results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000);

  for (let symbol of symbols) {
    try {
      let querySymbol = symbol;
      if (!symbol.includes('.') && /^[A-Z]+$/.test(symbol)) {
        querySymbol = `${symbol}.NS`;
      }
      const quote = await yahooFinance.quote(querySymbol);
      const rtData = await fetchRealtimeData(querySymbol);
      if (!rtData) {
        results.push({ symbol, error: 'No real-time data available' });
        continue;
      }
      const history = await fetchHistoricalData(querySymbol, past7Days, now, '1d');
      const detailedInfo = await fetchDetailedInfo(querySymbol);
      const news = await fetchNews(querySymbol);

      results.push({
        symbol: querySymbol,
        name: quote.longName || symbol,
        dates: rtData.dates,
        prices: rtData.prices,
        history,
        change: quote.regularMarketChange,
        changePercentage: quote.regularMarketChangePercent,
        marketCap: quote.marketCap,
        detailedInfo,
        news
      });
    } catch (error) {
      console.error(`Error fetching stock price for ${symbol}:`, error);
      results.push({ symbol, error: 'Unable to fetch data' });
    }
  }
  if (underPrice !== undefined) {
    return results.filter((r) => r.prices[0] < underPrice);
  }
  return results;
}

// Fetch trending (top) stocks.
async function getTopStocks(limit = 5, underPrice) {
  let results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000);

  try {
    const cookieResponse = await axios.get('https://www.nseindia.com', {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
        'Accept-Language': 'en-US,en;q=0.9'
      }
    });
    const cookies = cookieResponse.headers['set-cookie'];
    const cookieHeader = cookies ? cookies.join('; ') : '';

    const nseResponse = await axios.get(
      'https://www.nseindia.com/api/live-analysis-variations?index=gainers',
      {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
          'Accept': 'application/json',
          'Accept-Language': 'en-US,en;q=0.9',
          'Referer': 'https://www.nseindia.com/',
          'Cookie': cookieHeader,
        },
      }
    );
    const trendingData = nseResponse.data?.NIFTY?.data;
    if (!trendingData || trendingData.length === 0) {
      throw new Error('No trending data available from NSE API');
    }


    const symbols = trendingData
      .map((item) => item.symbol)
      .slice(0, limit)
      .map((sym) => (sym.includes('.') ? sym : sym + '.NS'));
    for (const symbol of symbols) {
      try {
        const quote = await yahooFinance.quote(symbol);
        const rtData = await fetchRealtimeData(symbol);
        if (!rtData) continue;
        const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
        const detailedInfo = await fetchDetailedInfo(symbol);
        const news = await fetchNews(symbol);
        results.push({
          symbol,
          name: quote.longName || symbol,
          dates: rtData.dates,
          prices: rtData.prices,
          history,
          change: quote.regularMarketChange,
          changePercentage: quote.regularMarketChangePercent,
          marketCap: quote.marketCap,
          detailedInfo,
          news
        });
      } catch (err) {
        console.error(`Error fetching realtime data for ${symbol}:`, err);
      }
    }
  } catch (error) {
    console.error('Error fetching top stocks from NSE:', error);
    return { error: 'Unable to fetch trending Indian stocks from NSE.' };
  }
  if (underPrice !== undefined) {
    results = results.filter((r) => r.prices[0] < underPrice);
  }
  return results;
}

// Fetch real-time crypto data.
async function getCryptoPrice(symbols, currency = 'USD', underPrice) {
  let conversionRate = 1;
  if (currency === 'INR') {
    try {
      const rateQuote = await yahooFinance.quote('USDINR=X');
      conversionRate = rateQuote.regularMarketPrice || 1;
    } catch (error) {
      console.error('Error fetching conversion rate:', error);
    }
  }
  const results = [];
  const now = new Date();
  const past7Days = new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000);
  for (let symbol of symbols) {
    try {
      if (!symbol.includes('-')) {
        symbol = `${symbol}-USD`;
      }
      const quote = await yahooFinance.quote(symbol);
      const rtData = await fetchRealtimeData(symbol);
      if (!rtData) {
        results.push({ symbol, error: 'No real-time data available' });
        continue;
      }
      let price = rtData.prices[0];
      if (currency === 'INR') {
        price = price * conversionRate;
      }
      const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
      let detailedInfo = null;
      let news = [];
      try {
        detailedInfo = await fetchDetailedInfo(symbol);
        news = await fetchNews(symbol);
      } catch (err) {
        console.error(`Error fetching detailed info or news for ${symbol}:`, err);
      }
      results.push({
        symbol,
        name: quote.shortName || symbol,
        dates: rtData.dates,
        prices: [price],
        history,
        change: quote.regularMarketChange,
        changePercentage: quote.regularMarketChangePercent,
        marketCap: quote.marketCap,
        detailedInfo,
        news
      });
    } catch (error) {
      console.error(`Error fetching crypto price for ${symbol}:`, error);
      results.push({ symbol, error: 'Unable to fetch data' });
    }
  }
  if (underPrice !== undefined) {
    const filtered = results.filter((r) => r.prices[0] < underPrice);
    return filtered.length > 0 ? filtered : [{ message: `No cryptocurrencies found with a price under ${underPrice}.` }];
  }
  return results;
}

async function getTopCryptos(limit = 5, currency = 'USD', underPrice) {
  let conversionRate = 1;
  if (currency === 'INR') {
    try {
      const rateQuote = await yahooFinance.quote('USDINR=X');
      conversionRate = rateQuote.regularMarketPrice || 1;
    } catch (error) {
      console.error('Error fetching conversion rate:', error);
    }
  }
  try {
    const response = await fetch(
      `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${limit}&page=1`
    );
    const coins = await response.json();
    if (!coins || !coins.length) {
      throw new Error('Failed to fetch top cryptocurrencies');
    }
    let results = [];
    const now = new Date();
    const past7Days = new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000);
    for (const coin of coins) {
      const symbol = `${coin.symbol.toUpperCase()}-USD`;
      try {
        const quote = await yahooFinance.quote(symbol);
        const rtData = await fetchRealtimeData(symbol);
        if (!rtData) continue;
        let price = rtData.prices[0];
        if (currency === 'INR') {
          price = price * conversionRate;
        }
        const history = await fetchHistoricalData(symbol, past7Days, now, '1d');
        results.push({
          symbol,
          name: quote.shortName || coin.name,
          dates: rtData.dates,
          prices: [price],
          history,
          change: quote.regularMarketChange,
          changePercentage: quote.regularMarketChangePercent,
          marketCap: quote.marketCap,
        });
      } catch (err) {
        console.error(`Error processing ${symbol}:`, err);
      }
    }
    if (underPrice !== undefined) {
      results = results.filter((r) => r.prices[0] < underPrice);
      return results.length > 0 ? results : [{ message: `No cryptocurrencies found with a price under ${underPrice}.` }];
    }
    return results;
  } catch (error) {
    console.error('Error fetching top cryptos:', error);
    return { error: 'Unable to fetch top cryptos' };
  }
}

/**
 * New Function: Fetch realtime market status using NSELive.
 */
async function getMarketStatus() {
  try {
    const status = await nseLive.marketStatus();
    return status;
  } catch (error) {
    console.error("Error fetching realtime market status:", error);
    return { error: "Unable to fetch realtime market status" };
  }
}

/**
 * New Function: Fetch trade information for one or more equities using NSELive.
 */
async function getTradeInfo({ symbols }) {
  try {
    // Validate that symbols is an array
    if (!symbols || !Array.isArray(symbols)) {
      throw new Error("The 'symbols' parameter must be an array of strings.");
    }

    // Create an array of promises for each symbol
    const tradeInfoPromises = symbols.map(async (symbol) => {
      const info = await nseLive.tradeInfo(symbol);
      return { symbol, info };
    });

    // Wait for all promises to resolve
    const tradeInfos = await Promise.all(tradeInfoPromises);
    return tradeInfos;
  } catch (error) {
    console.error(`Error fetching trade info:`, error);
    return { error: "Unable to fetch trade info" };
  }
}


/**
 * New Function: Fetch live F&O data for a specific equity using NSELive.
 */
async function getStockQuoteFNO({ symbols, optionsRequiredMonth }) {
  try {
    // Create an array of promises for each symbol
    const dataPromises = symbols.map(async (symbol) => {
      const rawData = await nseLive.stockQuoteFNO(symbol);
      // Process the rawData as done before:
      const underlyingValue = rawData.underlyingValue;
      const futuresData = [];
      const optionsData = [];

      if (Array.isArray(rawData.stocks)) {
        rawData.stocks.forEach((stock) => {
          const meta = stock.metadata;
          const orderBook = stock.marketDeptOrderBook;
          if (!meta || !orderBook) return; // Skip if essential data is missing

          const commonFields = {
            lastPrice: meta.lastPrice,
            change: meta.change,
            pChange: meta.pChange,
            contractsTraded: meta.numberOfContractsTraded,
            totalTurnover: meta.totalTurnover,
            openInterest: orderBook.tradeInfo ? orderBook.tradeInfo.openInterest : undefined,
            changeInOpenInterest: orderBook.tradeInfo ? orderBook.tradeInfo.changeinOpenInterest : undefined,
            pChangeInOpenInterest: orderBook.tradeInfo ? orderBook.tradeInfo.pchangeinOpenInterest : undefined,
            orderBook: {
              bid: orderBook.bid,
              ask: orderBook.ask,
            }
          };

          if (meta.instrumentType === 'Stock Futures') {
            futuresData.push({
              ...commonFields,
              volatility: {
                daily: orderBook.otherInfo ? orderBook.otherInfo.dailyvolatility : undefined,
                annualised: orderBook.otherInfo ? orderBook.otherInfo.annualisedVolatility : undefined,
                implied: orderBook.otherInfo ? orderBook.otherInfo.impliedVolatility : undefined
              }
            });
          } else if (meta.instrumentType === 'Stock Options') {
            if (optionsRequiredMonth && meta.expiryDate) {
              const parts = meta.expiryDate.split('-');
              if (parts.length < 2) return;
              const monthStr = parts[1];
              if (monthStr.toLowerCase() !== optionsRequiredMonth.toLowerCase()) return;
            }
            optionsData.push({
              optionType: meta.optionType,
              strikePrice: meta.strikePrice,
              expiryDate: meta.expiryDate,
              identifier: meta.identifier,
              ...commonFields,
              impliedVolatility: orderBook.otherInfo ? orderBook.otherInfo.impliedVolatility : undefined
            });
          }
        });
      }

      const limitedOptionsData = optionsData.slice(0, 3);

      return {
        symbol,
        underlyingValue,
        futuresData,
        optionsData: limitedOptionsData,
        fut_timestamp: rawData.fut_timestamp,
        opt_timestamp: rawData.opt_timestamp,
        info: rawData.info
      };
    });

    // Wait for all the promises to resolve
    const allData = await Promise.all(dataPromises);
    return allData;
  } catch (error) {
    console.error("Error fetching critical F&O data for multiple symbols:", error);
    return { error: "Unable to fetch F&O data" };
  }
}



/**
 * New Function: Fetch chart data for a given symbol using NSELive.
 */
async function getChartData({ symbol, includeAdditionalData }) {
  try {
    const data = await nseLive.chartData(symbol, includeAdditionalData);
    return data;
  } catch (error) {
    console.error(`Error fetching chart data for ${symbol}:`, error);
    return { error: "Unable to fetch chart data" };
  }
}

// /**
//  * New Function: Fetch market turnover data for a given symbol using NSELive.
//  */
// async function getMarketTurnover({ symbol }) {
//   try {
//     const data = await nseLive.marketTurnover(symbol);
//     return data;
//   } catch (error) {
//     console.error(`Error fetching market turnover for ${symbol}:`, error);
//     return { error: "Unable to fetch market turnover" };
//   }
// }

// /**
//  * New Function: Fetch equity derivative turnover data for a given symbol using NSELive.
//  */
// async function getEquityDerivativeTurnover({ symbol }) {
//   try {
//     const data = await nseLive.equityDerivativeTurnover(symbol);
//     return data;
//   } catch (error) {
//     console.error(`Error fetching equity derivative turnover for ${symbol}:`, error);
//     return { error: "Unable to fetch equity derivative turnover" };
//   }
// }

/**
 * New Function: Fetch data of all indices using NSELive.
 */
async function getAllIndices() {
  try {
    const data = await nseLive.allIndices();
  return data;
  } catch (error) {
    console.error("Error fetching all indices:", error);
    return { error: "Unable to fetch all indices" };
  }
}

/**
 * New Function: Fetch live index data for a given symbol using NSELive.
 */
async function getLiveIndex({ symbols }) {
  try {
    // 1. Get all indices data
    const allIndices = await getAllIndices();

    if (allIndices.error) {
      return { error: allIndices.error };
    }

    // 2. Filter indices based on user query
    const filteredData = allIndices.data.filter(index =>
      symbols.some(symbol =>
        index.index.toLowerCase() === symbol.toLowerCase() ||
        index.indexSymbol.toLowerCase() === symbol.toLowerCase()
      )
    );

    // 3. Handle no matches
    if (!filteredData.length) {
      return {
        error: "No matching indices found. Available indices: " +
          allIndices.data.map(d => d.index).join(', ')
      };
    }

    return filteredData;
  } catch (error) {
    console.error('Error fetching live index:', error);
    return { error: "Unable to fetch index data" };
  }
}


/**
 * NEW FUNCTION: Fetch top gainers, top losers, or both based on the user query.
 */
async function getGainersAndLosersData({ query }) {
  try {
    const lowerQuery = query.toLowerCase();
    if (lowerQuery.includes("gainers") && lowerQuery.includes("losers")) {
      // Fetch both gainers and losers concurrently
      const [gainers, losers] = await Promise.all([
        nseLive.top10Gainers(),
        nseLive.top10Loosers()
      ]);
      return { gainers, losers };
    } else if (lowerQuery.includes("gainers")) {
      return await nseLive.top10Gainers();
    } else if (lowerQuery.includes("losers")) {
      return await nseLive.top10Loosers();
    } else {
      return { error: "Query not recognized. Please specify 'gainers', 'losers', or 'gainers and losers'." };
    }
  } catch (error) {
    console.error("Error fetching gainers and losers data:", error);
    return { error: "Unable to fetch gainers/losers data" };
  }
}

// Add a new helper function:
async function getVolumeGainers() {
  try {
    const data = await nseLive.volumeGainers();
    return data;
  } catch (error) {
    console.error("Error fetching volume gainers:", error);
    return { error: "Unable to fetch volume gainers data" };
  }
}

async function shouldPurchaseStocks({ symbols, period = '30days' }) {
  const now = new Date();
  let days;

  // Parse the period string to determine the number of days.
  if (typeof period === "string") {
    const lower = period.toLowerCase();
    const match = lower.match(/^(\d+)\s*(day|days|month|months|year|years)$/);
    if (match) {
      const value = parseInt(match[1], 10);
      const unit = match[2];
      if (unit.startsWith("day")) {
        days = value;
      } else if (unit.startsWith("month")) {
        days = value * 30; // Approximate conversion: 1 month ≈ 30 days
      } else if (unit.startsWith("year")) {
        days = value * 365; // Approximate conversion: 1 year ≈ 365 days
      }
    }
  }
  if (!days) {
    days = 30; // Default to 30 days if period is not valid.
  }

  // Calculate the start date based on the number of days.
  const startDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
  const recommendations = [];

  for (const symbol of symbols) {
    try {
      // Ensure symbol is in correct format for Indian stocks.
      const querySymbol = symbol.includes('.') ? symbol : `${symbol}.NS`;

      // Fetch historical data over the period.
      const historicalData = await fetchHistoricalData(querySymbol, startDate, now, '1d');
      if (!historicalData || historicalData.length === 0) {
        recommendations.push({
          symbol: querySymbol,
          recommendation: "Insufficient historical data to provide a recommendation."
        });
        continue;
      }

      // Calculate the average closing price over the period.
      const total = historicalData.reduce((acc, item) => acc + item.price, 0);
      const averagePrice = total / historicalData.length;

      // Fetch current stock data.
      const currentData = await yahooFinance.quote(querySymbol);
      const currentPrice = currentData.regularMarketPrice;

      // Generate a recommendation.
      let recommendation = "";
      if (currentPrice < averagePrice * 0.98) {
        recommendation = "The current price is below the recent average, indicating a potential buying opportunity.";
      } else if (currentPrice > averagePrice * 1.02) {
        recommendation = "The current price is above the recent average, which may suggest it is overvalued at this time.";
      } else {
        recommendation = "The current price is close to the recent average; further analysis is recommended before purchasing.";
      }

      recommendations.push({
        symbol: querySymbol,
        currentPrice,
        averagePrice,
        recommendation,
        note: "This analysis is based solely on historical price data and is not personalized financial advice. Please consult a financial advisor before making any investment decisions."
      });
    } catch (error) {
      console.error(`Error processing ${symbol}:`, error);
      recommendations.push({
        symbol,
        recommendation: "Error processing data for this symbol."
      });
    }
  }

  return recommendations;
}








async function calculateStockROI(symbol, period) {
  let days;
  switch (period) {
    case '1month':
      days = 30;
      break;
    case '3month':
      days = 90;
      break;
    case '6month':
      days = 180;
      break;
    case '1year':
      days = 365;
      break;
    default:
      throw new Error('Invalid period specified');
  }

  const now = new Date();
  const startDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);

  try {
    // Normalize the symbol to follow the Indian market convention if needed.
    let querySymbol = symbol;
    if (!symbol.includes('.') && /^[A-Z]+$/.test(symbol)) {
      querySymbol = `${symbol}.NS`;
    }
    // Fetch historical data for the computed period. Assume this function returns an array of data points sorted by date.
    const history = await fetchHistoricalData(querySymbol, startDate, now, '1d');
    if (!history || history.length === 0) {
      return { symbol, error: 'No historical data available for the specified period' };
    }
    // Assume the first entry is the earliest price and the last entry is the most recent.
    const startPrice = history[0].price;
    const endPrice = history[history.length - 1].price;
    const roi = ((endPrice - startPrice) / startPrice) * 100;
    return { symbol: querySymbol, period, startPrice, endPrice, roi };
  } catch (error) {
    console.error(`Error calculating ROI for ${symbol}:`, error);
    return { symbol, error: 'Unable to calculate ROI' };
  }
}





async function getHighestReturnStock(args) {
  const { period } = args;
  const urlMap = {
    '1month': 'https://www.screener.in/screens/300202/stocks-with-good-1-month-returns/?sort=return+over+1month&order=desc',
    '3month': 'https://www.screener.in/screens/355769/highest-return-in-3-months/?sort=return+over+3months&order=desc',
    '6month': 'https://www.screener.in/screens/264786/highest-returns-in-six-months/',
    '1year': 'https://www.screener.in/screens/355766/highest-return-in-1-year/'
  };
  const periodKeyMap = {
    '1month': '1M Return %',
    '3month': '3M Return %',
    '6month': '6M Return %',
    '1year': '1Y Return %'
  };

  try {
    const response = await axios.get(urlMap[period], {
      headers: {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
        "Accept-Language": "en-US,en;q=0.9",
      }
    });

    const $ = load(response.data);
    const table = $('div.responsive-holder.fill-card-width table.data-table');
    if (!table.length) return { error: "No table found" };

    const scrapedData = [];
    table.find('tbody tr').each((index, row) => {
      const cols = $(row).find('td');
      if (!cols.length) return;

      // Extract details from each row. Adjust indexes if necessary.
      const stockName = $(cols[1]).text().trim();
      const returnText = $(cols).last().text().trim();
      const returnValue = parseFloat(returnText);

      scrapedData.push({
        name: stockName,
        [periodKeyMap[period]]: returnValue
      });
    });

    // Return the full scraped data array
    return scrapedData;
  } catch (error) {
    console.error("Error in getHighestReturnStock:", error);
    return { error: error.message };
  }
}










async function getBestStocksUnderPrice(args) {
  const { minPrice, maxPrice, maxMarketCap } = args;
  const browser = await puppeteer.launch({ headless: true, args: ['--no-sandbox', '--disable-setuid-sandbox'] });
  const page = await browser.newPage();

  // Inline helper function to parse market cap values
  const parseMarketCap = (marketCapText) => {
    if (!marketCapText) return null;
    // Handle "Lakh Cr." format (e.g., "1 Lakh Cr." = 100,000 Cr.)
    if (marketCapText.includes('Lakh')) {
      const value = parseFloat(marketCapText.replace(' Lakh Cr.', '').replace(/,/g, ''));
      return value * 100000; // Convert Lakh Cr. to Cr.
    }
    // Handle "Cr." format (e.g., "1,000 Cr." = 1000 Cr.)
    if (marketCapText.includes('Cr.')) {
      return parseFloat(marketCapText.replace(' Cr.', '').replace(/,/g, ''));
    }
    const parsedValue = parseFloat(marketCapText.replace(/,/g, ''));
    return isNaN(parsedValue) ? null : parsedValue;
  };

  try {
    // Navigate to Screener.in login page
    await page.goto('https://www.screener.in/login/', { waitUntil: 'networkidle2' });

    // Enter login credentials
    await page.type('input[name="username"]', process.env.SCREENER_USERNAME, { delay: 100 });
    await page.type('input[name="password"]', process.env.SCREENER_PASSWORD, { delay: 100 });

    // Click the login button and wait for navigation
    await Promise.all([
      page.click('button[type="submit"]'),
      page.waitForNavigation({ waitUntil: 'networkidle2' }),
    ]);

    console.log('Login successful');

    // Construct query parts
    const queryParts = [
      "Sales growth 3Years > 10",
      "Profit growth 3Years > 10",
      "Debt to equity < 0.5",
    ];

    // Price condition
    if (minPrice !== undefined) {
      queryParts.push(`Current price > ${minPrice} AND Current price < ${maxPrice}`);
    } else {
      queryParts.push(`Current price < ${maxPrice}`);
    }

    queryParts.push("Sales > 500");

    // Market Cap condition
    if (maxMarketCap !== undefined) {
      queryParts.push(`Market Capitalization < ${maxMarketCap}`);
    }

    // Encode query
    const query = queryParts.join(" AND\r\n");
    const encodedQuery = encodeURIComponent(query)
      .replace(/%20/g, '+')
      .replace(/%0D%0A/g, '%0D%0A');

    const url = `https://www.screener.in/screen/raw/?sort=&order=&source_id=&query=${encodedQuery}`;
    console.log('Navigating to URL:', url);
    await page.goto(url, { waitUntil: 'networkidle2' });
    await page.waitForSelector('div.responsive-holder.fill-card-width table.data-table tbody tr');

    const html = await page.content();
    const $ = load(html); // Ensure Cheerio is imported: const { load } = require('cheerio');

    const stocks = [];
    $('div.responsive-holder.fill-card-width table.data-table tbody tr').each((index, row) => {
      const cols = $(row).find('td');
      if (cols.length < 14) return;

      const marketCapText = $(cols[4]).text().trim();
      const marketCapValue = parseMarketCap(marketCapText);

      const stockData = {
        name: $(cols[1]).find('a').text().trim(),
        url: `https://www.screener.in${$(cols[1]).find('a').attr('href')}`,
        cmp: parseFloat($(cols[2]).text().trim().replace(/,/g, '')),
        peRatio: parseFloat($(cols[3]).text().trim()),
        marketCap: marketCapText,
        marketCapValue: marketCapValue,
        salesVar3Yrs: parseFloat($(cols[11]).text().trim()),
        profitVar3Yrs: parseFloat($(cols[12]).text().trim()),
        debtToEquity: parseFloat($(cols[13]).text().trim())
      };

      stocks.push(stockData);
    });

    // Post-filtering for accuracy
    let filteredStocks = stocks;
    if (minPrice !== undefined) {
      filteredStocks = filteredStocks.filter(stock => stock.cmp > minPrice);
    }
    if (maxPrice !== undefined) {
      filteredStocks = filteredStocks.filter(stock => stock.cmp < maxPrice);
    }
    if (maxMarketCap !== undefined) {
      filteredStocks = filteredStocks.filter(stock => stock.marketCapValue <= maxMarketCap);
    }

    return filteredStocks;

  } catch (error) {
    console.error('Error:', error);
    return { error: error.message };
  } finally {
    await browser.close();
  }
}











async function getOptionChainData({ symbol, strikePrice, optionType, expiryDate }) {
  try {
    // Fetch cookies required by NSE
    const cookieResponse = await axios.get('https://www.nseindia.com', {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
        'Accept-Language': 'en-US,en;q=0.9'
      }
    });
    const cookies = cookieResponse.headers['set-cookie'];
    const cookieHeader = cookies ? cookies.join('; ') : '';

    // Fetch option chain data
    const url = `https://www.nseindia.com/api/option-chain-indices?symbol=${symbol}`;
    const response = await axios.get(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
        'Accept': 'application/json',
        'Accept-Language': 'en-US,en;q=0.9',
        'Referer': 'https://www.nseindia.com/',
        'Cookie': cookieHeader,
      },
    });

    const data = response.data;

    // Get current date and filter out expired dates
    // Filter valid expiry dates (current and future)
    const currentMoment = moment();
    const validExpiryDates = data.records.expiryDates
      .map(expiry => moment(expiry, 'DD-MMM-YYYY', true))
      .filter(expiryMoment => expiryMoment.isSameOrAfter(currentMoment, 'day'))
      .sort((a, b) => a - b) // Sort ascending
      .map(m => m.format('DD-MMM-YYYY'));

    if (!validExpiryDates.length) return { error: "No future expiries available" };

    // Parse user-provided expiryDate
    let targetExpiry;
    if (expiryDate) {
      const dateFormats = [
      'DD-MMM-YYYY', // e.g., 27-Mar-2025
      'D-MMM-YYYY',
      'DD MMM YYYY',
      'D MMM YYYY',
      'MMMM D, YYYY',
      'MMM D, YYYY',
      'YYYY-MM-DD',
      'YYYY-M-D',
      'MMMM YYYY', 
      'YYYY',
      'MMM', 
      'MMMM'
    ];

    // Try parsing as exact date first
    const parsedExact = moment(expiryDate, dateFormats, true);
    if (parsedExact.isValid()) {
      const exactExpiry = parsedExact.format('DD-MMM-YYYY');
      if (validExpiryDates.includes(exactExpiry)) {
        targetExpiry = exactExpiry;
      }
    }

    // Handle partial dates (month/year)
    if (!targetExpiry) {
      const parsed = moment(expiryDate, dateFormats, true);
      if (parsed.isValid()) {
        let possibleDates = validExpiryDates.map(d => ({
          date: moment(d, 'DD-MMM-YYYY'),
          formatted: d
        }));

        // Filter by month/year
        if (parsed.month() !== undefined) { // Month specified
          const targetMonth = parsed.month();
          possibleDates = possibleDates.filter(d => d.date.month() === targetMonth);
        }
        if (parsed.year() !== undefined) { // Year specified
          const targetYear = parsed.year();
          possibleDates = possibleDates.filter(d => d.date.year() === targetYear);
        }

        if (possibleDates.length === 0) {
          return { error: `No expiry found for '${expiryDate}'. Valid: ${validExpiryDates.join(', ')}` };
        }

        // Sort ascending and pick earliest date for month, latest for year
        possibleDates.sort((a, b) => a.date - b.date);
        if (parsed.year() === undefined && parsed.month() !== undefined) {
          targetExpiry = possibleDates[0].formatted; // Earliest in month
        } else {
          targetExpiry = possibleDates[possibleDates.length - 1].formatted; // Latest in year
        }
      }
    }

    if (!targetExpiry) return { error: `Invalid expiry: ${expiryDate}` };
  } else {
    targetExpiry = validExpiryDates[0]; // Nearest expiry
  }

  // Find matching strike and expiry
  const entry = data.records.data.find(item =>
    item.strikePrice === strikePrice &&
    item.expiryDate === targetExpiry
  );

  if (!entry) return { error: 'No data for specified strike/expiry' };

  // Process and return the option data
  const optionData = entry[optionType];
    if (!optionData) return { error: 'Option type not found' };

    // Calculate moneyness
    const underlyingPrice = optionData.underlyingValue;
    const isInTheMoney = optionType === 'PE'
      ? strikePrice >= underlyingPrice
      : strikePrice <= underlyingPrice;

    // Analyze OI changes
    const oiAnalysis = optionData.changeinOpenInterest > 0
      ? 'Open interest is increasing, suggesting growing trader interest.'
      : 'Open interest is decreasing, indicating a lack of conviction among traders.';

    // Generate recommendation based on the analyzed data
    const recommendation = generateRecommendation(optionData, optionType);

    return {
      symbol,
      strikePrice,
      optionType,
      expiryDate: targetExpiry,
      openInterest: optionData.openInterest,
      changeinOpenInterest: optionData.changeinOpenInterest,
      pChangeInOI: optionData.pchangeinOpenInterest,
      lastPrice: optionData.lastPrice,
      impliedVolatility: optionData.impliedVolatility,
      underlyingValue: underlyingPrice,
      moneyness: isInTheMoney ? 'In-the-money' : 'Out-of-the-money',
      analysis: {
        oiTrend: oiAnalysis,
        volatilityStatus: optionData.impliedVolatility > 40 ? 'High IV' : 'Normal IV',
        riskRewardRatio: (underlyingPrice / strikePrice).toFixed(2)
      },
      recommendation
    };

  } catch (error) {
    console.error('Error fetching option data:', error);
    return { error: 'Failed to fetch option chain data' };
  }
}

function generateRecommendation(optionData, optionType) {
  const underlying = optionData.underlyingValue;
  const strike = optionData.strikePrice;
  const isInTheMoney = optionType === 'PE'
    ? strike >= underlying
    : strike <= underlying;

  // Moneyness recommendation
  let moneynessRecommendation = '';
  if (optionType === 'PE') {
    moneynessRecommendation = isInTheMoney
      ? "The put option is in-the-money, providing intrinsic value."
      : "The put option is out-of-the-money; a significant move downward in the underlying index is required to profit.";
  } else {
    moneynessRecommendation = isInTheMoney
      ? "The call option is in-the-money, providing intrinsic value."
      : "The call option is out-of-the-money; the underlying index must move higher for profitability.";
  }

  // Open Interest analysis
  const oiTrend = optionData.changeinOpenInterest > 0
    ? "The increasing open interest indicates that more traders are entering this position, suggesting emerging sentiment."
    : "The decreasing open interest might indicate waning trader interest.";

  // Implied Volatility assessment
  const volatilityStatus = optionData.impliedVolatility > 40
    ? "The high implied volatility suggests that the option premium may be inflated due to market uncertainty."
    : "The implied volatility is within a normal range, implying fair pricing of the option.";

  // Risk–Reward Ratio Analysis
  const riskRewardRatio = (underlying / strike).toFixed(2);
  const riskRewardRecommendation = riskRewardRatio > 1
    ? "A significant move in the underlying asset is needed to make the option profitable."
    : "The risk/reward balance appears acceptable given the current market conditions.";

  // Overall Recommendation Statement
  const overallRecommendation = `
Recommendation for ${optionData.underlying} ${strike} ${optionType === 'PE' ? 'Put' : 'Call'} Option:
- Moneyness: ${moneynessRecommendation}
- Open Interest: ${oiTrend}
- Implied Volatility: ${volatilityStatus}
- Risk/Reward: ${riskRewardRecommendation}

Overall, if you have a strong directional view (for example, expecting a bearish trend for a put option) and the market conditions align with these signals, this option might serve as a good speculative or hedging play. Otherwise, consider waiting for clearer indicators or exploring other strike levels.
  `;

  return overallRecommendation;
}


// /**
//  * New Function: Fetch index option chain for a given symbol using NSELive.
//  */
// async function getIndexOptionChain({ symbol }) {
//   try {
//     const data = await nseLive.indexOptionChain(symbol);
//     const logEntry = [
//       `Timestamp: ${new Date().toISOString()}`,
//       `Symbol: ${symbol}`,
//       `Futures Data: ${JSON.stringify(data, null, 2)}`,
//       '-------------------------\n'
//     ].join('\n');

//     fs.appendFile('InOPChain.log', logEntry, (err) => {
//       if (err) {
//         console.error('Error writing F&O data to file:', err);
//       }
//     });

//     return data;
//   } catch (error) {
//     console.error(`Error fetching index option chain for ${symbol}:`, error);
//     return { error: "Unable to fetch index option chain" };
//   }
// }

/**
 * Fetch company information from MongoDB Atlas.
 */
async function getCompanyInfo(args) {
  let category = args?.category || 'all';
  if (category === 'subscription') {
    category = 'pricing';
  }
  const companyDoc = await CompanyInfo.findOne({ name: 'Profit Flow' }).lean();
  if (!companyDoc) {
    throw new Error('Company information not found in the database.');
  }
  return category === 'all' ? companyDoc : { [category]: companyDoc[category] };
}

export async function POST(request) {
  try {
    const { messages } = await request.json();
    const userId = 'static-user-123'; // Replace with dynamic user ID in real app

    // Fetch user's previous reports
    const userLog = await UserChatLog.findOne({ userId });
    const reports = [];
    if (userLog) {
      userLog.messages.forEach(msg => {
        if (msg.actions?.report) {
          reports.push(msg.actions.reportMessage);
        }
      });
    }

    // Call OpenAI to get the initial assistant response.
    const initialResponse = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content:
            "You are a highly specialized financial analyst assistant for company 'profit flow' focused exclusively on Indian stocks, crypto analysis. Provide responses in structured markdown format with clear bullet points, proper spacing between topics, and dynamic chart headings based on the query. Respond in a professional tone and include relevant suggestions when applicable.\n\n",
        },
        ...messages,
      ],
      functions,
      function_call: 'auto',
    });
    const message = initialResponse.choices[0].message;
    
    // If OpenAI requested a function call, process that.
    if (message.function_call) {
      const functionName = message.function_call.name;
      const args = JSON.parse(message.function_call.arguments || '{}');
      let functionResponse;

      // Dispatch to the appropriate helper function.
      switch (functionName) {
        case 'get_stock_price':
          functionResponse = await getStockPrice(args.symbols, args.underPrice);
          break;
        case 'get_top_stocks':
          functionResponse = await getTopStocks(args.limit || 2, args.underPrice);
          break;
        case 'get_crypto_price':
          functionResponse = await getCryptoPrice(args.symbols, args.currency || 'USD', args.underPrice);
          break;
        case 'get_top_cryptos':
          functionResponse = await getTopCryptos(args.limit || 2, args.currency || 'USD', args.underPrice);
          break;
        case 'get_company_info':
          functionResponse = await getCompanyInfo(args);
          break;
        case 'get_market_status':
          functionResponse = await getMarketStatus();
          break;
        // New cases for additional NSELive endpoints:
        case 'get_trade_info':
          functionResponse = await getTradeInfo(args);
          break;
        case 'get_stock_quote_fno':
          functionResponse = await getStockQuoteFNO(args);
          break;
        case 'get_chart_data':
          functionResponse = await getChartData(args);
          break;
        case 'get_gainers_and_losers':
          functionResponse = await getGainersAndLosersData(args);
          break;
        case 'get_volume_gainers':
          functionResponse = await getVolumeGainers();
          break;
        case 'should_purchase_stock':
          functionResponse = await shouldPurchaseStocks(args);
          break;
        case 'calculate_stock_roi':
          functionResponse = await calculateStockROI(args.symbol, args.period);
          break;
        case 'get_highest_return_stock':
          functionResponse = await getHighestReturnStock(args);
          break;
        case 'get_best_stocks_under_price':
          functionResponse = await getBestStocksUnderPrice(args);
          break;
        // case 'get_market_turnover':
        //   functionResponse = await getMarketTurnover(args);
        //   break;
        // case 'get_equity_derivative_turnover':
        //   functionResponse = await getEquityDerivativeTurnover(args);
        //   break;
        case 'get_all_indices':
          functionResponse = await getAllIndices();
          break;
        case 'get_live_index':
          functionResponse = await getLiveIndex(args);
          break;
        case 'get_option_chain_data':
          functionResponse = await getOptionChainData(args);
          break;
        // case 'get_index_option_chain':
        //   if (!args.symbol || args.symbol.trim() === "") {
        //     args.symbol = "NIFTY";
        //   }
        //   functionResponse = await getIndexOptionChain(args);
        //   break;
        default:
          functionResponse = { error: 'Function not supported' };
      }
      // Process chart data: compute a 15-day SMA for each asset
      if (functionResponse && Array.isArray(functionResponse) && functionResponse.length > 0) {
        if (functionResponse[0].history && functionResponse[0].history.length > 0) {
          const labels = functionResponse[0].history.map((item) =>
            new Date(item.date).toLocaleDateString()
          );
          const priceDatasets = [];
          functionResponse.forEach((asset, index) => {
            const priceData = asset.history.map((item) => item.price);
            const datasetColor = `hsl(${(index * 360) / functionResponse.length}, 70%, 50%)`;
            priceDatasets.push({
              label: asset.symbol || asset.name || `Asset ${index + 1}`,
              data: priceData,
              fill: false,
              borderColor: datasetColor,
              backgroundColor: datasetColor,
              tension: 0.1,
            });
            if (priceData.length > 0) {
              // Compute a 15-day SMA (cumulative average if fewer than 15 days)
              const sma15 = calculateSMA(priceData, 15);
              priceDatasets.push({
                label: `${asset.symbol || asset.name} 15-Day SMA`,
                data: sma15,
                fill: false,
                borderColor: "yellow",
                borderDash: [5, 5],
                tension: 0.1,
              });
            }
            const volumeData = asset.history.map((item) => item.volume);
            priceDatasets.push({
              label: `${asset.symbol || asset.name} Volume`,
              data: volumeData,
              type: 'bar',
              yAxisID: 'volume-y-axis',
              backgroundColor: 'rgba(75, 192, 192, 0.2)',
              borderColor: 'rgba(75, 192, 192, 1)',
              borderWidth: 1,
              order: 0, // Draw volume behind other datasets
            });
          });
          const chartData = { labels, datasets: priceDatasets };
          functionResponse.chartData = chartData;
          functionResponse.chartTitle = `${functionResponse
            .map((item) => item.symbol)
            .join(" & ")} Price History`;
        }
      }

      let finalResponse;
      if (functionName === "get_company_info") {
        finalResponse = await openai.chat.completions.create({
          model: "gpt-4o-mini",
          messages: [
            ...messages,
            {
              role: "system",
              content:
                "You are a friendly advisor providing company information. Keep your response clear, concise, and conversational. Limit your answer to under three paragraphs and include any offers naturally.",
            },
            {
              role: "user",
              content: `Company Data:\n${JSON.stringify(functionResponse, null, 2)}`,
            },
          ],
          temperature: 0.7,
          max_tokens: 500,
        });
      } else {
        const responseTemplate = `Please generate a creative and professional financial update using the data provided below.
Data:
${JSON.stringify(functionResponse, null, 2)}

Ensure your response is engaging, well-structured, and adapts to the query context without using tables.`;
        finalResponse = await openai.chat.completions.create({
          model: "gpt-4o-mini",
          messages: [
            ...messages,
            {
              role: "system",
              content:
                "You are a highly specialized financial analyst assistant focused exclusively on Indian stocks and crypto analysis. Provide responses in structured markdown format using clear headings and full sentences that form a cohesive narrative. Respond in a professional tone and include relevant suggestions when applicable.\n\n" +
                "STRICT RULES:\n" +
                "- Keep response under 100 words.\n" +
                "- Tailor your language based on the user's technical tone: If the user communicates in a non-technical way, provide clear and simple explanations; if the user uses technical language, adopt a more detailed explanation.\n" +
                "- Provide only the data that is directly relevant to the query. Avoid including excessive or extraneous information.\n" +
                "- Highlight essential data points, such as **current price**, in bold and present all related details in a clear and concise manner.\n" +
                "Based on the provided input data, generate an in-depth market analysis report that dynamically identifies all significant metrics. Include a detailed explanation of what each metric represents, why it is important, and its implications for investors, along with additional context such as trend analysis, comparisons, or potential risks.\n" +
                "Ensure your response goes beyond simply listing data points by including clear, explanatory sentences and a narrative that ties the data together. Use markdown headings (like '## Company Profile' and '## Key Financial Metrics') to organize the information. Add numbering with bullet points for heading and subheadings\n" +
                (reports.length > 0
                  ? `User feedback to consider: ${reports.slice(-3).join(". ")}. Address these concerns appropriately.\n\n`
                  : "")
            },
            {
              role: "user",
              content: responseTemplate,
            },
          ],
          temperature: 0.6,
          max_tokens: 1000,
        });
      }
      console.log(reports);
      return NextResponse.json({
        ...finalResponse.choices[0].message,
        rawData: functionResponse,
        functionName: message.function_call.name,
      });
    } else {
      return NextResponse.json({
        role: "assistant",
        content:
          message.content ||
          "I'm here to help! Could you please clarify your request?",
      });
    }
  } catch (error) {
    console.error("API Error:", error);
    return NextResponse.json(
      {
        error: "Financial data currently unavailable. Please try again later.",
        details:
          process.env.NODE_ENV === "development" ? error.message : undefined,
      },
      { status: 500 }
    );
  }
}